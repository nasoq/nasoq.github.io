{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NASOQ ^1 ^1 is a scalable and efficient Quadratic Programming solver that obtains solutions to requested accuracies. Also, the NASOQ library includes a linear system solver for indefinite systems which, is named LBL. NASOQ is tested for an extensive number of QP problems from real applications that are also shared and are accessible from this repository. 1. NASOQ /n\u028czo\u028ak/ is a Persian/Indian/Urdu name that means delicate and indicates accuracy. Why NASOQ? NASOQ is: Accurate: NASOQ converges to all reasonably requested accuracy thresholds. NASOQ provides the lowest failure rate among existing open-source and commercial solvers for a range of real QP problems. Fast: NASOQ uses an efficient sparsity-oriented row modification algorithm (SOMOD) and a fast indefinite solver (LBL) enabling quick solve of the intermediate indefinite linear system of equations arising along the QP solve. Versatile: NASOQ efficiently and accurately solves QP problems from a wide range of applications including, contact simulation, shape deformation, model predictive control, model reconstruction, and... Scalable: NASOQ uses the sparsity pattern of the problem to efficiently solve QP problems with small to a large number of variables and constraints. Problems from 10 to 100 thousands of variables and from 10 to thousands of linear constraints. Citing us If you are using NASOQ, please cite the NASOQ paper or support us by putting a star in the NASOQ GitHub repository. @article{Cheshmi2020NASOQ, author = {Cheshmi, Kazem and Kaufman, Danny M. and Kamil, Shoaib and Dehnavi, Maryam Mehri}, title = {NASOQ: Numerically Accurate Sparsity-Oriented QP Solver}, journal = {ACM Transactions on Graphics}, year = {2020}, volume = {39}, number = {4} We are keen to hear your success stories with NASOQ. We are also ready to help you to fit NASOQ into your needs. Please contact us . Credits The people have been involved in the development of NASOQ: Kazem Cheshmi Danny M. Kaufman Shoaib Kamil Maryam Mehri Dehnavi","title":"Overview"},{"location":"#why-nasoq","text":"NASOQ is: Accurate: NASOQ converges to all reasonably requested accuracy thresholds. NASOQ provides the lowest failure rate among existing open-source and commercial solvers for a range of real QP problems. Fast: NASOQ uses an efficient sparsity-oriented row modification algorithm (SOMOD) and a fast indefinite solver (LBL) enabling quick solve of the intermediate indefinite linear system of equations arising along the QP solve. Versatile: NASOQ efficiently and accurately solves QP problems from a wide range of applications including, contact simulation, shape deformation, model predictive control, model reconstruction, and... Scalable: NASOQ uses the sparsity pattern of the problem to efficiently solve QP problems with small to a large number of variables and constraints. Problems from 10 to 100 thousands of variables and from 10 to thousands of linear constraints.","title":"Why NASOQ?"},{"location":"#citing-us","text":"If you are using NASOQ, please cite the NASOQ paper or support us by putting a star in the NASOQ GitHub repository. @article{Cheshmi2020NASOQ, author = {Cheshmi, Kazem and Kaufman, Danny M. and Kamil, Shoaib and Dehnavi, Maryam Mehri}, title = {NASOQ: Numerically Accurate Sparsity-Oriented QP Solver}, journal = {ACM Transactions on Graphics}, year = {2020}, volume = {39}, number = {4} We are keen to hear your success stories with NASOQ. We are also ready to help you to fit NASOQ into your needs. Please contact us .","title":"Citing us"},{"location":"#credits","text":"The people have been involved in the development of NASOQ: Kazem Cheshmi Danny M. Kaufman Shoaib Kamil Maryam Mehri Dehnavi","title":"Credits"},{"location":"getting-started-lbl/","text":"LBL is a part of the NASOQ repository and is similarly a header-only library and does not need installation. Here we explain how LBL C++ API can be used to solve your sparse indefinite linear systems in your code. C++ API An example of how to use LBL in your code is provided in the nasoq/examples directory, and here we explain the example step by step. We assume your project is somewhere like in nasoq\\examples\\ . First you need to clone the NASOQ repository in your project folder: cd nasoq/examples/ git clone https://github.com/sympiler/nasoq After cloning NASOQ, you need to modify the CMakeLists of your project file to include NASOQ dependencies. Project LBL_Test in the CMakeLists of the nasoq/examples/ directory shows the components that you need to add to your CMake file. After modifying the CMake file of your project, you need to ensure the library dependencies of NASOQ are installed. NASOQ needs METIS and MKL BLAS Libraries as prerequisites. If the installation paths of these libraries are in the system path, CMake should be able to handle dependencies. If not, you need to set CMake variables as shown below: cd where/cloned/nasoq mkdir build cd build cmake -DMKL_ROOT_PATH = path/to/intel -DMETIS_ROOT_PATH = path/to//metis-5.1.0/build/Linux-x86_64/ -DCMAKE_BUILD_TYPE = Release .. After setting up dependencies, You can call LBL solver to solve your linear system by including <linear_solver_wrapper.h> and preparing its inputs, as shown in the following code. #include \"linear_solver_wrapper.h\" /* * Solving Hx = q * H is a sparse matrix stored in CSC format * q is a dense array */ int main ( int argc , char * argv []){ /// Declaring input matrices // allocate ... q [ 0 ] = - 4 ; q [ 1 ] = - 4 ; Hp [ 0 ] = 0 ; Hp [ 1 ] = 1 ; Hp [ 2 ] = 2 ; Hi [ 0 ] = 0 ; Hi [ 1 ] = 1 ; Hx [ 0 ] = 2 ; Hx [ 1 ] = 2 ; auto * H = new nasoq :: CSC ; H -> nzmax = nnzH ; H -> ncol = H -> nrow = sizeH ; H -> p = Hp ; H -> i = Hi ; H -> x = Hx ; H -> stype =- 1 ; /// Solving the linear system auto * lbl = new nasoq :: SolverSettings ( H , q ); lbl -> ldl_variant = 4 ; lbl -> req_ref_iter = 2 ; lbl -> solver_mode = 0 ; lbl -> reg_diag = pow ( 10 , - 9 ); lbl -> symbolic_analysis (); lbl -> numerical_factorization (); double * x = lbl -> solve_only (); /// Printing results // expected x={-2,-2}; std :: cout << \"Solution: \" ; for ( int i = 0 ; i < sizeH ; ++ i ) { std :: cout << x [ i ] << \",\" ; } /// Free memory ... } For details about inputs, outputs, and settings of LBL, please see the LBL document page . Finally, you will build your project with NASOQ by emitting the make command. You can also use LBL inside the NASOQ source tree. One example of using LBL is shown in the repository in the nasoq/eigen_interface directory. Choosing between in-source or out-source depends on your project settings.","title":"Getting Started with LBL"},{"location":"getting-started-lbl/#c-api","text":"An example of how to use LBL in your code is provided in the nasoq/examples directory, and here we explain the example step by step. We assume your project is somewhere like in nasoq\\examples\\ . First you need to clone the NASOQ repository in your project folder: cd nasoq/examples/ git clone https://github.com/sympiler/nasoq After cloning NASOQ, you need to modify the CMakeLists of your project file to include NASOQ dependencies. Project LBL_Test in the CMakeLists of the nasoq/examples/ directory shows the components that you need to add to your CMake file. After modifying the CMake file of your project, you need to ensure the library dependencies of NASOQ are installed. NASOQ needs METIS and MKL BLAS Libraries as prerequisites. If the installation paths of these libraries are in the system path, CMake should be able to handle dependencies. If not, you need to set CMake variables as shown below: cd where/cloned/nasoq mkdir build cd build cmake -DMKL_ROOT_PATH = path/to/intel -DMETIS_ROOT_PATH = path/to//metis-5.1.0/build/Linux-x86_64/ -DCMAKE_BUILD_TYPE = Release .. After setting up dependencies, You can call LBL solver to solve your linear system by including <linear_solver_wrapper.h> and preparing its inputs, as shown in the following code. #include \"linear_solver_wrapper.h\" /* * Solving Hx = q * H is a sparse matrix stored in CSC format * q is a dense array */ int main ( int argc , char * argv []){ /// Declaring input matrices // allocate ... q [ 0 ] = - 4 ; q [ 1 ] = - 4 ; Hp [ 0 ] = 0 ; Hp [ 1 ] = 1 ; Hp [ 2 ] = 2 ; Hi [ 0 ] = 0 ; Hi [ 1 ] = 1 ; Hx [ 0 ] = 2 ; Hx [ 1 ] = 2 ; auto * H = new nasoq :: CSC ; H -> nzmax = nnzH ; H -> ncol = H -> nrow = sizeH ; H -> p = Hp ; H -> i = Hi ; H -> x = Hx ; H -> stype =- 1 ; /// Solving the linear system auto * lbl = new nasoq :: SolverSettings ( H , q ); lbl -> ldl_variant = 4 ; lbl -> req_ref_iter = 2 ; lbl -> solver_mode = 0 ; lbl -> reg_diag = pow ( 10 , - 9 ); lbl -> symbolic_analysis (); lbl -> numerical_factorization (); double * x = lbl -> solve_only (); /// Printing results // expected x={-2,-2}; std :: cout << \"Solution: \" ; for ( int i = 0 ; i < sizeH ; ++ i ) { std :: cout << x [ i ] << \",\" ; } /// Free memory ... } For details about inputs, outputs, and settings of LBL, please see the LBL document page . Finally, you will build your project with NASOQ by emitting the make command. You can also use LBL inside the NASOQ source tree. One example of using LBL is shown in the repository in the nasoq/eigen_interface directory. Choosing between in-source or out-source depends on your project settings.","title":"C++ API"},{"location":"getting-started-nasoq/","text":"NASOQ is a header-only library and does not need installation. Here we explain how NASOQ C++ API can be used to solve your QP problems in your code. C++ API An example of how to use NASOQ in your code is provided in nasoq/examples and here we explain the example step by step. We assume your project is somewhere like in nasoq\\examples\\ . First you need to clone the NASOQ repository in your project folder: cd nasoq/examples/ git clone https://github.com/sympiler/nasoq After cloning NASOQ, you need to modify the CMakeLists of your project file to include NASOQ dependencies. Project NASOQ_Test in the CMakeLists of nasoq/examples/ shows the components that you need to add to your CMake file. After modifying the CMake file of your project, you need to ensure the library dependencies of NASOQ are installed. NASOQ needs METIS and MKL BLAS Libraries as prerequisites. If the installation paths of these libraries are in the system path, CMake should be able to handle dependencies. If not, you need to set CMake variables as shown below: cd where/cloned/nasoq mkdir build cd build cmake -DMKL_ROOT_PATH = path/to/intel -DMETIS_ROOT_PATH = path/to//metis-5.1.0/build/Linux-x86_64/ -DCMAKE_BUILD_TYPE = Release .. NASOQ optionally needs Suitesparse library, and if it is not in the system path, you can use -DSUITE_ROOT_PATH=path/to/suitesparse to tell CMake where Suitesparse is installed. After setting up dependencies, You can call NASOQ solver to solve your QP problems by including <nasoq.h> , and by preparing its inputs, as shown in the following code. #include <nasoq.h> int main (){ /// Allocate ... /// Inputs q [ 0 ] = - 4 ; q [ 1 ] = - 4 ; Hp [ 0 ] = 0 ; Hp [ 1 ] = 1 ; Hp [ 2 ] = 2 ; Hi [ 0 ] = 0 ; Hi [ 1 ] = 1 ; Hx [ 0 ] = 2 ; Hx [ 1 ] = 2 ; Cp [ 0 ] = 0 ; Cp [ 1 ] = 4 ; Cp [ 2 ] = 8 ; Ci [ 0 ] = 0 ; Ci [ 1 ] = 1 ; Ci [ 2 ] = 2 ; Ci [ 3 ] = 3 ; Ci [ 4 ] = 0 ; Ci [ 5 ] = 1 ; Ci [ 6 ] = 2 ; Ci [ 7 ] = 3 ; Cx [ 0 ] = 2 ; Cx [ 1 ] = 1 ; Cx [ 2 ] =- 1 ; Cx [ 3 ] =- 2 ; Cx [ 4 ] = 1 ; Cx [ 5 ] =- 1 ; Cx [ 6 ] =- 1 ; Cx [ 7 ] = 1 ; d [ 0 ] = 2 ; d [ 1 ] = 1 ; d [ 2 ] = 1 ; d [ 3 ] = 2 ; /// Solving the QP pronlem nasoq :: Nasoq * qm ; qm = new nasoq :: Nasoq ( sizeH , Hp , Hi , Hx , q , CRows , CCols , Cp , Ci , Cx , d ); qm -> reg_diag = pow ( 10 , - 9 ); qm -> eps_abs = pow ( 10 , - 3 ); qm -> eps_rel = pow ( 10 , - 3 ); qm -> inner_iter_ref = 0 ; qm -> outer_iter_ref = 0 ; int converged = qm -> solve (); /// Printing results if ( converged ) std :: cout << \"The problem is converged \\n \" ; // expected x={0.4,1.2}; auto * x = qm -> primal_vars ; std :: cout << \"Primal variables: \" ; for ( int i = 0 ; i < sizeH ; ++ i ) { std :: cout << x [ i ] << \",\" ; } // expected z = {1.6,0,0,0} std :: cout << \" \\n Dual variables: \" ; auto * z = qm -> dual_vars ; for ( int i = 0 ; i < CRows ; ++ i ) { std :: cout << z [ i ] << \",\" ; } /// Free memory ... } For details about inputs, outputs, and settings of NASOQ, please see the NASOQ document page . Finally, you will build your project with NASOQ by emitting the make command. You can also use NASOQ inside the source tree. One example of using nasoq is shown in the nasoq/eigen_interface directory. Choosing between in-source or out-source depends on your project settings. Command-line interface In addition to C++ API, a terminal interface is also provided in the NASOQ repository. To use this interface, you need to follow the below instructions to build the interface, i.e., NASOQ-BIN : cd where/you/want/to/install/nasoq/ git clone https://github.com/sympiler/nasoq cd nasoq mkdir build cd build cmake -DMKL_ROOT_PATH = path/to/intel -DMETIS_ROOT_PATH = path/to//metis-5.1.0/build/Linux-x86_64/ -DCMAKE_BUILD_TYPE = Release .. make After the build is done the terminal interface can be launched by calling NASOQ-BIN with an input QP problem. The list of switches, which can be seen by commanding NASOQ-BIN -h . Some important options are shown below: -i : input SMP file -e : Requested accuracy ,e.g., -3 -v : NASOQ variant, e.g., fixed or tuned For details of options please check NASOQ document page . And for details about SMP format, please check SMP repository page .","title":"Getting Started with NASOQ"},{"location":"getting-started-nasoq/#c-api","text":"An example of how to use NASOQ in your code is provided in nasoq/examples and here we explain the example step by step. We assume your project is somewhere like in nasoq\\examples\\ . First you need to clone the NASOQ repository in your project folder: cd nasoq/examples/ git clone https://github.com/sympiler/nasoq After cloning NASOQ, you need to modify the CMakeLists of your project file to include NASOQ dependencies. Project NASOQ_Test in the CMakeLists of nasoq/examples/ shows the components that you need to add to your CMake file. After modifying the CMake file of your project, you need to ensure the library dependencies of NASOQ are installed. NASOQ needs METIS and MKL BLAS Libraries as prerequisites. If the installation paths of these libraries are in the system path, CMake should be able to handle dependencies. If not, you need to set CMake variables as shown below: cd where/cloned/nasoq mkdir build cd build cmake -DMKL_ROOT_PATH = path/to/intel -DMETIS_ROOT_PATH = path/to//metis-5.1.0/build/Linux-x86_64/ -DCMAKE_BUILD_TYPE = Release .. NASOQ optionally needs Suitesparse library, and if it is not in the system path, you can use -DSUITE_ROOT_PATH=path/to/suitesparse to tell CMake where Suitesparse is installed. After setting up dependencies, You can call NASOQ solver to solve your QP problems by including <nasoq.h> , and by preparing its inputs, as shown in the following code. #include <nasoq.h> int main (){ /// Allocate ... /// Inputs q [ 0 ] = - 4 ; q [ 1 ] = - 4 ; Hp [ 0 ] = 0 ; Hp [ 1 ] = 1 ; Hp [ 2 ] = 2 ; Hi [ 0 ] = 0 ; Hi [ 1 ] = 1 ; Hx [ 0 ] = 2 ; Hx [ 1 ] = 2 ; Cp [ 0 ] = 0 ; Cp [ 1 ] = 4 ; Cp [ 2 ] = 8 ; Ci [ 0 ] = 0 ; Ci [ 1 ] = 1 ; Ci [ 2 ] = 2 ; Ci [ 3 ] = 3 ; Ci [ 4 ] = 0 ; Ci [ 5 ] = 1 ; Ci [ 6 ] = 2 ; Ci [ 7 ] = 3 ; Cx [ 0 ] = 2 ; Cx [ 1 ] = 1 ; Cx [ 2 ] =- 1 ; Cx [ 3 ] =- 2 ; Cx [ 4 ] = 1 ; Cx [ 5 ] =- 1 ; Cx [ 6 ] =- 1 ; Cx [ 7 ] = 1 ; d [ 0 ] = 2 ; d [ 1 ] = 1 ; d [ 2 ] = 1 ; d [ 3 ] = 2 ; /// Solving the QP pronlem nasoq :: Nasoq * qm ; qm = new nasoq :: Nasoq ( sizeH , Hp , Hi , Hx , q , CRows , CCols , Cp , Ci , Cx , d ); qm -> reg_diag = pow ( 10 , - 9 ); qm -> eps_abs = pow ( 10 , - 3 ); qm -> eps_rel = pow ( 10 , - 3 ); qm -> inner_iter_ref = 0 ; qm -> outer_iter_ref = 0 ; int converged = qm -> solve (); /// Printing results if ( converged ) std :: cout << \"The problem is converged \\n \" ; // expected x={0.4,1.2}; auto * x = qm -> primal_vars ; std :: cout << \"Primal variables: \" ; for ( int i = 0 ; i < sizeH ; ++ i ) { std :: cout << x [ i ] << \",\" ; } // expected z = {1.6,0,0,0} std :: cout << \" \\n Dual variables: \" ; auto * z = qm -> dual_vars ; for ( int i = 0 ; i < CRows ; ++ i ) { std :: cout << z [ i ] << \",\" ; } /// Free memory ... } For details about inputs, outputs, and settings of NASOQ, please see the NASOQ document page . Finally, you will build your project with NASOQ by emitting the make command. You can also use NASOQ inside the source tree. One example of using nasoq is shown in the nasoq/eigen_interface directory. Choosing between in-source or out-source depends on your project settings.","title":"C++ API"},{"location":"getting-started-nasoq/#command-line-interface","text":"In addition to C++ API, a terminal interface is also provided in the NASOQ repository. To use this interface, you need to follow the below instructions to build the interface, i.e., NASOQ-BIN : cd where/you/want/to/install/nasoq/ git clone https://github.com/sympiler/nasoq cd nasoq mkdir build cd build cmake -DMKL_ROOT_PATH = path/to/intel -DMETIS_ROOT_PATH = path/to//metis-5.1.0/build/Linux-x86_64/ -DCMAKE_BUILD_TYPE = Release .. make After the build is done the terminal interface can be launched by calling NASOQ-BIN with an input QP problem. The list of switches, which can be seen by commanding NASOQ-BIN -h . Some important options are shown below: -i : input SMP file -e : Requested accuracy ,e.g., -3 -v : NASOQ variant, e.g., fixed or tuned For details of options please check NASOQ document page . And for details about SMP format, please check SMP repository page .","title":"Command-line interface"},{"location":"interfaces/","text":"We are trying to build different interface to ease the use of NASOQ in different frameworks/languages. Eigen interface An Eigen interface is provided in the NASOQ repository in the nasoq/eigen_interface directory. The interface needs Eigen to be installed beforehand. There are two demos, eigen_nasoq_driver.cpp and eigen_lbl_driver.cpp\" that show how NASOQ and LBL can be called from Eigen. You need to only include #include \"lbl_eigen.h\" for using LBL and #include \"nasoq_eigen.h\" for using NASOQ in your Eigen code. Matlab interface The NASOQ Matlab interface needs Libigl and Eigen as well as other dependencies that NASOQ has (see getting started with NASOQ ). A simple manual for installing the Matlab interface is provided in the nasoq/matlab directory.","title":"Interfaces"},{"location":"interfaces/#eigen-interface","text":"An Eigen interface is provided in the NASOQ repository in the nasoq/eigen_interface directory. The interface needs Eigen to be installed beforehand. There are two demos, eigen_nasoq_driver.cpp and eigen_lbl_driver.cpp\" that show how NASOQ and LBL can be called from Eigen. You need to only include #include \"lbl_eigen.h\" for using LBL and #include \"nasoq_eigen.h\" for using NASOQ in your Eigen code.","title":"Eigen interface"},{"location":"interfaces/#matlab-interface","text":"The NASOQ Matlab interface needs Libigl and Eigen as well as other dependencies that NASOQ has (see getting started with NASOQ ). A simple manual for installing the Matlab interface is provided in the nasoq/matlab directory.","title":"Matlab interface"},{"location":"linear-solver/","text":"Algorithm overview LBL is an algorithm for factorizing a sparse indefinite linear system of equations. LBL solves Hx=q Hx=q for x x , where q q is a dense vector, and H H is a sparse symmetric indefinite matrix. To solve the system Hx = q Hx = q , LBL applies LDL factorization to decompose the matrix H H into H = P_{fill} P_{S} (LDL^{T} + E) P_{S}^{T} P_{fill}^{T} H = P_{fill} P_{S} (LDL^{T} + E) P_{S}^{T} P_{fill}^{T} where D D is a blocked diagonal symmetric matrix (due to our use of Bunch-Kaufman pivoting[schenk et.al. 2006]), L L is a sparse lower triangular matrix, E E is a diagonal perturbation matrix (necessary to avoid zero diagonals, which can cause instabilities, P_{fill} P_{fill} is a fill-reducing ordering (such as METIS[karypis 1995]), and P_S P_S is reordering due to pivoting. Given this factorization of the matrix, LBL then uses L L and D D along with q q (the right-hand side) to quickly compute the solution x x via triangular solve and an iterative refinement method. The overall process of the factorization in LBL closely follows that of standard sparse linear system solvers. For efficient factorization, the sparsity pattern of H H is analyzed during symbolic analysis . The symbolic analysis uses the sparsity pattern of H H to construct symbolic information , which consists of the fill-reducing ordering P_{fill} P_{fill} and the sparsity pattern of L L . Symbolic information guides the numeric factorization , which operates on the actual numeric values of H H to compute the nonzero values of L L and D D . Matrices L L and D D are then used to find x x with a lower triangular system solve and blocked diagonal solver. An iterative refinement algorithm, GMRES is also used when accurate solution is required. In addition to solving a standalone linear system of equations, LBL also supports row modification when the sparsity pattern of changes is known ahead of time. The LBL operating mode that supports row modification is used in NASOQ and is called sparsity oriented row modification (SoMoD) . Here we only discuss the interface LBL as a standalone solver. Settings The three parameters that are explained in the NASOQ algorithm is in common with LBL. So the three important parameters of max_iter: the maximum number of refinement iterations, GMRES for incrementally improving the solution of a linear system after the solve phase; stop_tol: the threshold defining the upper bound for the residual accuracy of the linear system during the refinement phase; diag_perturb: value added to zero-entry diagonals of the matrix to stabilize LBL.","title":"LBL algorithm"},{"location":"linear-solver/#algorithm-overview","text":"LBL is an algorithm for factorizing a sparse indefinite linear system of equations. LBL solves Hx=q Hx=q for x x , where q q is a dense vector, and H H is a sparse symmetric indefinite matrix. To solve the system Hx = q Hx = q , LBL applies LDL factorization to decompose the matrix H H into H = P_{fill} P_{S} (LDL^{T} + E) P_{S}^{T} P_{fill}^{T} H = P_{fill} P_{S} (LDL^{T} + E) P_{S}^{T} P_{fill}^{T} where D D is a blocked diagonal symmetric matrix (due to our use of Bunch-Kaufman pivoting[schenk et.al. 2006]), L L is a sparse lower triangular matrix, E E is a diagonal perturbation matrix (necessary to avoid zero diagonals, which can cause instabilities, P_{fill} P_{fill} is a fill-reducing ordering (such as METIS[karypis 1995]), and P_S P_S is reordering due to pivoting. Given this factorization of the matrix, LBL then uses L L and D D along with q q (the right-hand side) to quickly compute the solution x x via triangular solve and an iterative refinement method. The overall process of the factorization in LBL closely follows that of standard sparse linear system solvers. For efficient factorization, the sparsity pattern of H H is analyzed during symbolic analysis . The symbolic analysis uses the sparsity pattern of H H to construct symbolic information , which consists of the fill-reducing ordering P_{fill} P_{fill} and the sparsity pattern of L L . Symbolic information guides the numeric factorization , which operates on the actual numeric values of H H to compute the nonzero values of L L and D D . Matrices L L and D D are then used to find x x with a lower triangular system solve and blocked diagonal solver. An iterative refinement algorithm, GMRES is also used when accurate solution is required. In addition to solving a standalone linear system of equations, LBL also supports row modification when the sparsity pattern of changes is known ahead of time. The LBL operating mode that supports row modification is used in NASOQ and is called sparsity oriented row modification (SoMoD) . Here we only discuss the interface LBL as a standalone solver.","title":"Algorithm overview"},{"location":"linear-solver/#settings","text":"The three parameters that are explained in the NASOQ algorithm is in common with LBL. So the three important parameters of max_iter: the maximum number of refinement iterations, GMRES for incrementally improving the solution of a linear system after the solve phase; stop_tol: the threshold defining the upper bound for the residual accuracy of the linear system during the refinement phase; diag_perturb: value added to zero-entry diagonals of the matrix to stabilize LBL.","title":"Settings"},{"location":"repository/","text":"Applications We assemble a repository for sparse QP problems of different scales, most of which come from applications in animation, geometry processing, and simulation. An overview of the repository is provided in the SMP page . Here we explain the storage format that is used in the Sparse Mathematical Programming repository (SMP) and also, the corresponding I/O routines of the format. We also explain how SMP is used in NASOQ benchmark to fairly compare different QP solvers across SMP problems. SMP storage format Sparse Mathematical Programming (SMP) format aims for providing a unified and readable format that is compatible with existing sparse matrix formats such as matrix market format. SMP uses the YAML format to serialize the matrices of a QP problem into a single unified file in a readable format. An example SMP format is shown below: Description\" : | Sparse Mathematical Programming Repository ID = 00000 category = Control application = example name = test01 group = test source = author = Kazem Cheshmi date = 06/20 \"Fixed\" : | 0 \"Inequality\" : | %%MatrixMarket matrix coordinate real symmetric 3 2 4 1 1 10 2 1 1 1 2 -1 3 2 1 \"Inequality l-bounds\" : | %%MatrixMarket matrix array real general 3 1 10 2 -50 \"Inequality u-bounds\" : | %%MatrixMarket matrix array real general 3 1 inf 10 10 \"Linear\" : | %%MatrixMarket matrix array real general 2 1 0 0 \"Quadratic\" : | %%MatrixMarket matrix coordinate real symmetric 2 2 2 1 1 2 2 2 2 As shown a QP problem in the SMP format is stored in the general form of: \\begin{align} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad l \\leq C' x\\leq u \\end{align} that is more compressed than the general form that NASOQ supports which we call general inequality/equality form (IE) and is shown below: \\begin{align} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad C x\\leq d \\end{align} and also more compressed than another general form that we we call general bounded form (bounded) and is illustrated below: \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad l' \\leq C'' x\\leq u' \\end{align} \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad l' \\leq C'' x\\leq u' \\end{align} These three representations lead to the same optimal solution however, they are different in terms of storage requirements and also the number of iterations that one solver might need to solve the problem. SMP conversion We developed a repository for converting different representations of a QP problem, i.e., IE and Bounded forms to SMP and also from SMP to others. The repository does not have any dependency and to install: git clone https://github.com/sympiler/smp-format cd smp-format mkdir build cd build cmake -DCMAKE_BUILD_TYPE = Release .. make After building, three drivers, i.e., ie2smp , bounded2smp , and smp-convertor will be available. The ie2smp driver takes all matrices of a QP problem in IE format which are stored in matrix market format and generates an SMP format. The bounded2smp driver takes all matrices of a QP instance in the bounded format which are again stored in matrix market format and generates an SMP format. The smp-convertor shows an example of how SMP format is used as an intermediate format to convert every two formats together. NASOQ benchmark We also developed a unified framework to run all solvers with their settings for the problems in the SMP repository. The installation of the benchmark depends on the solvers that are added and their dependencies. The instructions for installing the benchmark is provided in the nasoq-benchmarks . Adding a new solver Adding a new solver to the benchmark is easy. The first step is to write a driver for the solver that takes an SMP format and generates the inputs that are needed for the solver. Three examples for OSQP, NASOQ, and Gurobi are provided in drivers subdirectory . As explained, the SMP repository provides support for different QP formats so they can be easily used here. The second step is to update the CMake file in the drivers subdirectory by adding a new project that builds the driver for the new solver. The third step is to add a line to the run_all.sh script, as shown below: echo \"Running [The name of the new solver] ...\" bash scripts/NASOQ_bench.sh $BUILDIR /drivers/ [ New-solver-bin ] $DATASET $eps \"-v [if it has a variant]\" > logs/new-solver-e ${ eps } .csv The run_all script runs all installed solvers for the specified dataset and the requested accuracy and generates the performance profile graphs.","title":"Sparse Mathematical Programming (SMP) Repository"},{"location":"repository/#applications","text":"We assemble a repository for sparse QP problems of different scales, most of which come from applications in animation, geometry processing, and simulation. An overview of the repository is provided in the SMP page . Here we explain the storage format that is used in the Sparse Mathematical Programming repository (SMP) and also, the corresponding I/O routines of the format. We also explain how SMP is used in NASOQ benchmark to fairly compare different QP solvers across SMP problems.","title":"Applications"},{"location":"repository/#smp-storage-format","text":"Sparse Mathematical Programming (SMP) format aims for providing a unified and readable format that is compatible with existing sparse matrix formats such as matrix market format. SMP uses the YAML format to serialize the matrices of a QP problem into a single unified file in a readable format. An example SMP format is shown below: Description\" : | Sparse Mathematical Programming Repository ID = 00000 category = Control application = example name = test01 group = test source = author = Kazem Cheshmi date = 06/20 \"Fixed\" : | 0 \"Inequality\" : | %%MatrixMarket matrix coordinate real symmetric 3 2 4 1 1 10 2 1 1 1 2 -1 3 2 1 \"Inequality l-bounds\" : | %%MatrixMarket matrix array real general 3 1 10 2 -50 \"Inequality u-bounds\" : | %%MatrixMarket matrix array real general 3 1 inf 10 10 \"Linear\" : | %%MatrixMarket matrix array real general 2 1 0 0 \"Quadratic\" : | %%MatrixMarket matrix coordinate real symmetric 2 2 2 1 1 2 2 2 2 As shown a QP problem in the SMP format is stored in the general form of: \\begin{align} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad l \\leq C' x\\leq u \\end{align} that is more compressed than the general form that NASOQ supports which we call general inequality/equality form (IE) and is shown below: \\begin{align} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad C x\\leq d \\end{align} and also more compressed than another general form that we we call general bounded form (bounded) and is illustrated below: \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad l' \\leq C'' x\\leq u' \\end{align} \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad l' \\leq C'' x\\leq u' \\end{align} These three representations lead to the same optimal solution however, they are different in terms of storage requirements and also the number of iterations that one solver might need to solve the problem.","title":"SMP storage format"},{"location":"repository/#smp-conversion","text":"We developed a repository for converting different representations of a QP problem, i.e., IE and Bounded forms to SMP and also from SMP to others. The repository does not have any dependency and to install: git clone https://github.com/sympiler/smp-format cd smp-format mkdir build cd build cmake -DCMAKE_BUILD_TYPE = Release .. make After building, three drivers, i.e., ie2smp , bounded2smp , and smp-convertor will be available. The ie2smp driver takes all matrices of a QP problem in IE format which are stored in matrix market format and generates an SMP format. The bounded2smp driver takes all matrices of a QP instance in the bounded format which are again stored in matrix market format and generates an SMP format. The smp-convertor shows an example of how SMP format is used as an intermediate format to convert every two formats together.","title":"SMP conversion"},{"location":"repository/#nasoq-benchmark","text":"We also developed a unified framework to run all solvers with their settings for the problems in the SMP repository. The installation of the benchmark depends on the solvers that are added and their dependencies. The instructions for installing the benchmark is provided in the nasoq-benchmarks .","title":"NASOQ benchmark"},{"location":"repository/#adding-a-new-solver","text":"Adding a new solver to the benchmark is easy. The first step is to write a driver for the solver that takes an SMP format and generates the inputs that are needed for the solver. Three examples for OSQP, NASOQ, and Gurobi are provided in drivers subdirectory . As explained, the SMP repository provides support for different QP formats so they can be easily used here. The second step is to update the CMake file in the drivers subdirectory by adding a new project that builds the driver for the new solver. The third step is to add a line to the run_all.sh script, as shown below: echo \"Running [The name of the new solver] ...\" bash scripts/NASOQ_bench.sh $BUILDIR /drivers/ [ New-solver-bin ] $DATASET $eps \"-v [if it has a variant]\" > logs/new-solver-e ${ eps } .csv The run_all script runs all installed solvers for the specified dataset and the requested accuracy and generates the performance profile graphs.","title":"Adding a new solver"},{"location":"solver/","text":"Algorithm overview NASOQ focuses on the solution of convex quadratic programming problems to find the linearly constrained minimizers of quadratic energies. In full generality our problem then is \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad C x\\leq d \\end{align} where the unknown minimizer x \\in \\mathbb{R}^n x \\in \\mathbb{R}^n is constrained by linear equality constraints A x=b A x=b and inequality constraints Cx\\leq d Cx\\leq d . Note that in many cases, we may have only inequality or equality constraints. However, in the following, without loss of generality, we consider the full mixed case. Here the symmetric matrix H H is, either by construction or standard user regularization, a positive-definite matrix, thus the QP is strictly convex. NASOQ is an active-set QP solver based on Goldfarb-Idnani (GI) [Goldfarb and Idnani, 1983] strategy. Active-set methods start with a feasible solution and keep a running set of proposed active inequality constraints \\mathcal{W} \\mathcal{W} to reach the optimal solution while maintaining feasibility conditions. Active-set methods are then either primal-feasible, preserving the primal-feasibility condition or else are dual-feasible, preserving the non-negativity condition. GI is a dual-feasible active-set approach, and so enables direct and inexpensive initialization. NASOQ begins by initializing an empty active-set proposal, \\mathcal{W} = \\emptyset \\mathcal{W} = \\emptyset with zero dual variables, z_0 = 0 z_0 = 0 . The resulting initial KKT system to solve is then the indefinite linear system, \\begin{bmatrix} H & A^T\\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} x_0\\\\ y_0 \\end{bmatrix} = \\begin{bmatrix} -q\\\\ b \\end{bmatrix} \\begin{bmatrix} H & A^T\\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} x_0\\\\ y_0 \\end{bmatrix} = \\begin{bmatrix} -q\\\\ b \\end{bmatrix} Then, each successive iteration of NASOQ improves the last iterate's solution by updating the active-set proposal \\mathcal{W} \\mathcal{W} and so the corresponding active-set constraint matrix C_{\\mathcal{W}} C_{\\mathcal{W}} and the right-hand side constraint vector c_{w} c_{w} . The NASOQ algorithm updates the active set by only adding one or removing one constraint in each successive iteration. Here w w is the activated constraint. The next descent direction for the QP is then determined by solving the updated KKT system, \\begin{bmatrix} H & A^T & C_{\\mathcal{W}}^T\\\\ A & 0 & 0 \\\\C_{\\mathcal{W}} & 0 & 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta z \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{w} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} \\begin{bmatrix} H & A^T & C_{\\mathcal{W}}^T\\\\ A & 0 & 0 \\\\C_{\\mathcal{W}} & 0 & 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta z \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{w} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} The dual and primal variables of the next iteration are then updated by finding step lengths along the computed descent directions, i.e., \\Delta x, \\Delta y, \\Delta z \\Delta x, \\Delta y, \\Delta z . The step lengths ensure that the activated constraint becomes primal-feasible and all dual variables remain dual-feasible. Thus, in each iteration, both the dual and primal variables corresponding to the constraints in the active set are both non-negative and primal-feasible. Variants NASOQ has two variants: NASOQ-Fixed and NASOQ-Tuned , and each of these two variants individually offers a different balance in the trade-off between efficiency and accuracy for larger-scale problems. A key feature of NASOQ is that in our construction of the linear system solver, i.e., LBL and the row modification, i.e., SoMoD we expose three parameters with direct and intuitive interpretations that enable us to balance efficiency against accuracy for different applications and problem scales. These three parameters are: max_iter: the maximum number of refinement iterations for incrementally improving the solution of a KKT system after the solve phase; stop_tol: the threshold defining the upper bound for the residual accuracy of the KKT system during the refinement phase; diag_perturb: value added to zero-entry diagonals of the KKT matrix to stabilize LBL and row modification in SoMod. NASOQ-Fixed works well across the board without changing a default setting. To use NASOQ-Fixed, you can set nasoq->variant = Fixed . NASOQ-Tuned uses a range of reasonable settings for these three parameters known as a priori, to perform a rapid sweep for improved accuracy. The setting for activating NASOQ-Tuned is: nasoq->variant = Tuned . Termination criteria The termination criteria in NASOQ are four conditions that are listed below: Primal-feasibility: \\Big( (Ax-b)^T, (\\max(\\textbf{0},Cx-d))^T \\Big)^T \\| < \\epsilon_f \\Big( (Ax-b)^T, (\\max(\\textbf{0},Cx-d))^T \\Big)^T \\| < \\epsilon_f Stationarity: |Hx + q + A^{T}y + C^{T}z\\| < \\epsilon_s |Hx + q + A^{T}y + C^{T}z\\| < \\epsilon_s Complementarity: |z \\odot (Cx-d)\\| < \\epsilon_c |z \\odot (Cx-d)\\| < \\epsilon_c , Here \\odot \\odot is the Hadamard (element-wise) product. Non-negativity: |\\min(\\textbf{0},z)\\| < \\epsilon_n |\\min(\\textbf{0},z)\\| < \\epsilon_n We design NASOQ and analyze QP methods on their ability to drive all four of these measures ( \\infty \\infty -norm) below a common, maximum error threshold accuracy: \\epsilon \\geq \\max(\\epsilon_f,\\epsilon_s,\\epsilon_c,\\epsilon_n) \\epsilon \\geq \\max(\\epsilon_f,\\epsilon_s,\\epsilon_c,\\epsilon_n) . While necessary accuracies for each of the four measures certainly change per application, a desirable goal for a general-purpose QP algorithm is to solve every reasonable problem to any requested accuracy. Here we design for general-purpose QP problems and so do not predict a priori what measures are most important. Thus we evaluate fitness by asking each solve to drive all measures below \\epsilon \\epsilon . To set the accuracy threshold in NASOQ, you may use the following: nasoq->eps = 1e-3; Settings The three different parameters, max_iter, stop_tol, diag_perturb that exist in NASOQ, often show a significant effect on the performance and accuracy of the solver. Also, requesting a more accurate solution, i.e., lower termination criteria or eps often leads to much more number of iterations and thus slower convergence time. NASOQ has some pre-defined variants, i.e., fixed and tuned, that is designed conservatively for the lowest failure rate. However, a customized setting can lead to better performance if the requirements of the application are known. Here we provide a few suggestions based on our experience with working with different real applications: Setting Property NASOQ Variant max_iter stop_tol diag_perturb eps Example Applications Low accuracy and fast predet 0 1e-15 1e-9 1e-3 Geometry processing, Model reconstruction accurate enough predet 1 1e-15 1e-9 1e-6 Contact simulations, Control The predet variant of NASOQ is a variant that takes the input settings determined by the user. If you are not sure, you may start with the fixed variant of NASOQ.","title":"NASOQ algorithm"},{"location":"solver/#algorithm-overview","text":"NASOQ focuses on the solution of convex quadratic programming problems to find the linearly constrained minimizers of quadratic energies. In full generality our problem then is \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad C x\\leq d \\end{align} where the unknown minimizer x \\in \\mathbb{R}^n x \\in \\mathbb{R}^n is constrained by linear equality constraints A x=b A x=b and inequality constraints Cx\\leq d Cx\\leq d . Note that in many cases, we may have only inequality or equality constraints. However, in the following, without loss of generality, we consider the full mixed case. Here the symmetric matrix H H is, either by construction or standard user regularization, a positive-definite matrix, thus the QP is strictly convex. NASOQ is an active-set QP solver based on Goldfarb-Idnani (GI) [Goldfarb and Idnani, 1983] strategy. Active-set methods start with a feasible solution and keep a running set of proposed active inequality constraints \\mathcal{W} \\mathcal{W} to reach the optimal solution while maintaining feasibility conditions. Active-set methods are then either primal-feasible, preserving the primal-feasibility condition or else are dual-feasible, preserving the non-negativity condition. GI is a dual-feasible active-set approach, and so enables direct and inexpensive initialization. NASOQ begins by initializing an empty active-set proposal, \\mathcal{W} = \\emptyset \\mathcal{W} = \\emptyset with zero dual variables, z_0 = 0 z_0 = 0 . The resulting initial KKT system to solve is then the indefinite linear system, \\begin{bmatrix} H & A^T\\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} x_0\\\\ y_0 \\end{bmatrix} = \\begin{bmatrix} -q\\\\ b \\end{bmatrix} \\begin{bmatrix} H & A^T\\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} x_0\\\\ y_0 \\end{bmatrix} = \\begin{bmatrix} -q\\\\ b \\end{bmatrix} Then, each successive iteration of NASOQ improves the last iterate's solution by updating the active-set proposal \\mathcal{W} \\mathcal{W} and so the corresponding active-set constraint matrix C_{\\mathcal{W}} C_{\\mathcal{W}} and the right-hand side constraint vector c_{w} c_{w} . The NASOQ algorithm updates the active set by only adding one or removing one constraint in each successive iteration. Here w w is the activated constraint. The next descent direction for the QP is then determined by solving the updated KKT system, \\begin{bmatrix} H & A^T & C_{\\mathcal{W}}^T\\\\ A & 0 & 0 \\\\C_{\\mathcal{W}} & 0 & 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta z \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{w} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} \\begin{bmatrix} H & A^T & C_{\\mathcal{W}}^T\\\\ A & 0 & 0 \\\\C_{\\mathcal{W}} & 0 & 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta z \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{w} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} The dual and primal variables of the next iteration are then updated by finding step lengths along the computed descent directions, i.e., \\Delta x, \\Delta y, \\Delta z \\Delta x, \\Delta y, \\Delta z . The step lengths ensure that the activated constraint becomes primal-feasible and all dual variables remain dual-feasible. Thus, in each iteration, both the dual and primal variables corresponding to the constraints in the active set are both non-negative and primal-feasible.","title":"Algorithm overview"},{"location":"solver/#variants","text":"NASOQ has two variants: NASOQ-Fixed and NASOQ-Tuned , and each of these two variants individually offers a different balance in the trade-off between efficiency and accuracy for larger-scale problems. A key feature of NASOQ is that in our construction of the linear system solver, i.e., LBL and the row modification, i.e., SoMoD we expose three parameters with direct and intuitive interpretations that enable us to balance efficiency against accuracy for different applications and problem scales. These three parameters are: max_iter: the maximum number of refinement iterations for incrementally improving the solution of a KKT system after the solve phase; stop_tol: the threshold defining the upper bound for the residual accuracy of the KKT system during the refinement phase; diag_perturb: value added to zero-entry diagonals of the KKT matrix to stabilize LBL and row modification in SoMod. NASOQ-Fixed works well across the board without changing a default setting. To use NASOQ-Fixed, you can set nasoq->variant = Fixed . NASOQ-Tuned uses a range of reasonable settings for these three parameters known as a priori, to perform a rapid sweep for improved accuracy. The setting for activating NASOQ-Tuned is: nasoq->variant = Tuned .","title":"Variants"},{"location":"solver/#termination-criteria","text":"The termination criteria in NASOQ are four conditions that are listed below: Primal-feasibility: \\Big( (Ax-b)^T, (\\max(\\textbf{0},Cx-d))^T \\Big)^T \\| < \\epsilon_f \\Big( (Ax-b)^T, (\\max(\\textbf{0},Cx-d))^T \\Big)^T \\| < \\epsilon_f Stationarity: |Hx + q + A^{T}y + C^{T}z\\| < \\epsilon_s |Hx + q + A^{T}y + C^{T}z\\| < \\epsilon_s Complementarity: |z \\odot (Cx-d)\\| < \\epsilon_c |z \\odot (Cx-d)\\| < \\epsilon_c , Here \\odot \\odot is the Hadamard (element-wise) product. Non-negativity: |\\min(\\textbf{0},z)\\| < \\epsilon_n |\\min(\\textbf{0},z)\\| < \\epsilon_n We design NASOQ and analyze QP methods on their ability to drive all four of these measures ( \\infty \\infty -norm) below a common, maximum error threshold accuracy: \\epsilon \\geq \\max(\\epsilon_f,\\epsilon_s,\\epsilon_c,\\epsilon_n) \\epsilon \\geq \\max(\\epsilon_f,\\epsilon_s,\\epsilon_c,\\epsilon_n) . While necessary accuracies for each of the four measures certainly change per application, a desirable goal for a general-purpose QP algorithm is to solve every reasonable problem to any requested accuracy. Here we design for general-purpose QP problems and so do not predict a priori what measures are most important. Thus we evaluate fitness by asking each solve to drive all measures below \\epsilon \\epsilon . To set the accuracy threshold in NASOQ, you may use the following: nasoq->eps = 1e-3;","title":"Termination criteria"},{"location":"solver/#settings","text":"The three different parameters, max_iter, stop_tol, diag_perturb that exist in NASOQ, often show a significant effect on the performance and accuracy of the solver. Also, requesting a more accurate solution, i.e., lower termination criteria or eps often leads to much more number of iterations and thus slower convergence time. NASOQ has some pre-defined variants, i.e., fixed and tuned, that is designed conservatively for the lowest failure rate. However, a customized setting can lead to better performance if the requirements of the application are known. Here we provide a few suggestions based on our experience with working with different real applications: Setting Property NASOQ Variant max_iter stop_tol diag_perturb eps Example Applications Low accuracy and fast predet 0 1e-15 1e-9 1e-3 Geometry processing, Model reconstruction accurate enough predet 1 1e-15 1e-9 1e-6 Contact simulations, Control The predet variant of NASOQ is a variant that takes the input settings determined by the user. If you are not sure, you may start with the fixed variant of NASOQ.","title":"Settings"}]}
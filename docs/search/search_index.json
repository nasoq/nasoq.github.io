{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NASOQ ^1 ^1 is a scalable and efficient Quadratic Programming solver that obtains solutions to requested accuracies. Also, the NASOQ library includes a linear system solver for indefinite systems which, is named LBL. NASOQ is tested for an extensive number of QP problems from real applications that are also shared and are accessible from this repository. 1. NASOQ /n\u028czo\u028ak/ is a Persian/Indian/Urdu word that means delicate and indicates accuracy. Why NASOQ? NASOQ is: Accurate: NASOQ converges to all reasonably requested accuracy thresholds. NASOQ provides the lowest failure rate among existing open-source and commercial solvers for a range of real QP problems. Fast: NASOQ uses an efficient sparsity-oriented row modification algorithm (SOMOD) and a fast indefinite solver (LBL) enabling quick solve of the intermediate indefinite linear system of equations arising along the QP solve. Versatile: NASOQ efficiently and accurately solves QP problems from a wide range of applications including, contact simulation, shape deformation, model predictive control, model reconstruction, and... Scalable: NASOQ uses the sparsity pattern of the problem to efficiently solve QP problems with small to a large number of variables and constraints. Problems from 10 to 100 thousands of variables and from 10 to thousands of linear constraints. Citing us If you are using NASOQ, please cite the NASOQ paper or support us by putting a star in the NASOQ GitHub repository. @article{Cheshmi2020NASOQ, author = {Cheshmi, Kazem and Kaufman, Danny M. and Kamil, Shoaib and Dehnavi, Maryam Mehri}, title = {NASOQ: Numerically Accurate Sparsity-Oriented QP Solver}, journal = {ACM Transactions on Graphics}, year = {2020}, volume = {39}, number = {4} We are keen to hear your success stories with NASOQ. We are also ready to help you to fit NASOQ into your needs. Please contact us . Credits The people have been involved in the development of NASOQ: Kazem Cheshmi Danny M. Kaufman Shoaib Kamil Maryam Mehri Dehnavi","title":"Overview"},{"location":"#why-nasoq","text":"NASOQ is: Accurate: NASOQ converges to all reasonably requested accuracy thresholds. NASOQ provides the lowest failure rate among existing open-source and commercial solvers for a range of real QP problems. Fast: NASOQ uses an efficient sparsity-oriented row modification algorithm (SOMOD) and a fast indefinite solver (LBL) enabling quick solve of the intermediate indefinite linear system of equations arising along the QP solve. Versatile: NASOQ efficiently and accurately solves QP problems from a wide range of applications including, contact simulation, shape deformation, model predictive control, model reconstruction, and... Scalable: NASOQ uses the sparsity pattern of the problem to efficiently solve QP problems with small to a large number of variables and constraints. Problems from 10 to 100 thousands of variables and from 10 to thousands of linear constraints.","title":"Why NASOQ?"},{"location":"#citing-us","text":"If you are using NASOQ, please cite the NASOQ paper or support us by putting a star in the NASOQ GitHub repository. @article{Cheshmi2020NASOQ, author = {Cheshmi, Kazem and Kaufman, Danny M. and Kamil, Shoaib and Dehnavi, Maryam Mehri}, title = {NASOQ: Numerically Accurate Sparsity-Oriented QP Solver}, journal = {ACM Transactions on Graphics}, year = {2020}, volume = {39}, number = {4} We are keen to hear your success stories with NASOQ. We are also ready to help you to fit NASOQ into your needs. Please contact us .","title":"Citing us"},{"location":"#credits","text":"The people have been involved in the development of NASOQ: Kazem Cheshmi Danny M. Kaufman Shoaib Kamil Maryam Mehri Dehnavi","title":"Credits"},{"location":"getting-started-lbl/","text":"LBL is a part of the NASOQ repository and can be installed similarly. Here we explain how LBL C++ API can be used to solve your sparse indefinite linear systems. Installation LBL installation is the same as NASOQ installation instructions C++ API examples C++ API examples for how to use LBL and SoMod in-tree and out-of-tree are provided in the nasoq/examples directory. For details, please see NASOQ C++ API . Here we show a snapshot of the LBL linear solver example ( nasoq/examples/lbl_main.cpp ): #include <nasoq/QP/linear_solver_wrapper.h> /* * Solving Hx = q * H is a sparse matrix stored in CSC format * q is a dense array */ int main ( int argc , char * argv []){ /// Declaring input matrices // allocate ... q [ 0 ] = -4 ; q [ 1 ] = -4 ; Hp [ 0 ] = 0 ; Hp [ 1 ] = 1 ; Hp [ 2 ] = 2 ; Hi [ 0 ] = 0 ; Hi [ 1 ] = 1 ; Hx [ 0 ] = 2 ; Hx [ 1 ] = 2 ; auto * H = new nasoq :: CSC ; H -> nzmax = nnzH ; H -> ncol = H -> nrow = sizeH ; H -> p = Hp ; H -> i = Hi ; H -> x = Hx ; H -> stype = -1 ; /// Solving the linear system auto * lbl = new nasoq :: SolverSettings ( H , q ); lbl -> ldl_variant = 4 ; lbl -> req_ref_iter = 2 ; lbl -> solver_mode = 0 ; lbl -> reg_diag = pow ( 10 , -9 ); lbl -> symbolic_analysis (); lbl -> numerical_factorization (); double * x = lbl -> solve_only (); /// Printing results // expected x={-2,-2}; std :: cout << \"Solution: \" ; for ( int i = 0 ; i < sizeH ; ++ i ) { std :: cout << x [ i ] << \",\" ; } /// Free memory ... } For details about inputs, outputs, and settings of LBL, please see the LBL document page . SoMoD: Sparsity Oriented Row Modification SoMoD is designed to update the factors of LDL factorization after one or multiple rows of the input matrix is modified. SoMoD is an expert routine that is only used inside NASOQ. SoMoD works when the sparsity pattern of changes is known as a priory. There is an example, lbl_somod_main.cpp on how to use SoMoD in nasoq/examples .","title":"Getting Started with LBL"},{"location":"getting-started-lbl/#installation","text":"LBL installation is the same as NASOQ installation instructions","title":"Installation"},{"location":"getting-started-lbl/#c-api-examples","text":"C++ API examples for how to use LBL and SoMod in-tree and out-of-tree are provided in the nasoq/examples directory. For details, please see NASOQ C++ API . Here we show a snapshot of the LBL linear solver example ( nasoq/examples/lbl_main.cpp ): #include <nasoq/QP/linear_solver_wrapper.h> /* * Solving Hx = q * H is a sparse matrix stored in CSC format * q is a dense array */ int main ( int argc , char * argv []){ /// Declaring input matrices // allocate ... q [ 0 ] = -4 ; q [ 1 ] = -4 ; Hp [ 0 ] = 0 ; Hp [ 1 ] = 1 ; Hp [ 2 ] = 2 ; Hi [ 0 ] = 0 ; Hi [ 1 ] = 1 ; Hx [ 0 ] = 2 ; Hx [ 1 ] = 2 ; auto * H = new nasoq :: CSC ; H -> nzmax = nnzH ; H -> ncol = H -> nrow = sizeH ; H -> p = Hp ; H -> i = Hi ; H -> x = Hx ; H -> stype = -1 ; /// Solving the linear system auto * lbl = new nasoq :: SolverSettings ( H , q ); lbl -> ldl_variant = 4 ; lbl -> req_ref_iter = 2 ; lbl -> solver_mode = 0 ; lbl -> reg_diag = pow ( 10 , -9 ); lbl -> symbolic_analysis (); lbl -> numerical_factorization (); double * x = lbl -> solve_only (); /// Printing results // expected x={-2,-2}; std :: cout << \"Solution: \" ; for ( int i = 0 ; i < sizeH ; ++ i ) { std :: cout << x [ i ] << \",\" ; } /// Free memory ... } For details about inputs, outputs, and settings of LBL, please see the LBL document page .","title":"C++ API examples"},{"location":"getting-started-lbl/#somod-sparsity-oriented-row-modification","text":"SoMoD is designed to update the factors of LDL factorization after one or multiple rows of the input matrix is modified. SoMoD is an expert routine that is only used inside NASOQ. SoMoD works when the sparsity pattern of changes is known as a priory. There is an example, lbl_somod_main.cpp on how to use SoMoD in nasoq/examples .","title":"SoMoD: Sparsity Oriented Row Modification"},{"location":"getting-started-nasoq/","text":"Here we explain how you can install NASOQ and use its C++ API to solve your QP problems. Installation Getting the source First you should clone the NASOQ repository in your project folder: git clone https://github.com/sympiler/nasoq You can also download one of the NASOQ releases from here . Required dependencies You should have the following packages to be able to install NASOQ: CMake: version 3.16 or higher C/C++ compiler: Any GCC, ICC, or Clang that support C++11 should work. You can always change your compiler by setting CMAKE_C_COMPILER and CMAKE_CXX_COMPILER . For example, the following changes the compiler to GCC-9: cmake -DCMAKE_C_COMPILER = /usr/bin/gcc-9 -DCMAKE_CXX_COMPILER = /usr/bin/g++-9 .. Optional dependencies Following packages improve the performance of NASOQ, but it is not necessary because the NASOQ build system handles it internally. You can skip these details if you are satisfied with the NASOQ performance as installed. We explain different alternatives that the NASOQ build system accepts. OpenMP: OpenMP enables thread-level parallelism in NASOQ. Without OpenMP, NASOQ runs sequentially. We are planning to add TBB as an alternative. If your compiler supports OpenMP, CMake detects it. GCC, ICC, and most LLVM versions natively support OpenMP. METIS: METIS is required for solving linear systems in NASOQ. CMake downloads METIS and installs it if it does not find in your system. You can always add your favorite local METIS installation to CMAKE_PREFIX_PATH=\"\" and NASOQ will use that instead. Alternatively, you can set METIS_INCDIR and METIS_LIBDIR to where METIS header and library are installed, respectively. BLAS Library: NASOQ needs a BLAS library for its supernodal sparse linear solver. It supports both MKL BLAS and OpenBLAS. You should set NASOQ_BLAS_BACKEND when you are installing NASOQ through CMake. The default BLAS is set to MKL as NASOQ is tested more thoroughly with MKL BLAS, but OpenBLAS works as well. MKL BLAS ( -DNASOQ_BLAS_BACKEND=\"MKL\" ): CMake detects the MKL library if you installed it on its default location. If you are using a new version, i.e., called oneAPI, you should set the include and binary directories to CMAKE_PREFIX_PATH (please make sure you set variables, e.g., source /opt/intel/oneapi/setvars.sh ). An example of using oneAPI 2021: cmake -DCMAKE_PREFIX_PATH=\"/opt/intel/oneapi/mkl/2021.2.0/lib/intel64/;/opt/intel/oneapi/mkl/2021.2.0/include/\" .. OpenBLAS ( -DNASOQ_BLAS_BACKEND=\"OpenBLAS\" ): NASOQ's build system downloads OpenBLAS and installs it if it does not detect it in your system. NASOQ should detect OpenBLAS if it is installed through apt or brew . LAPACK Library: The linear solver in NASOQ also uses LAPACK. LAPACK is often part of the BLAS library, such as MKL and OpenBLAS in Mac and Linux. However, if it is not included, or you have any installation issues due to LAPACK, you can use the LAPACK version that NASOQ downloads internally by setting -DNASOQ_USE_CLAPACK=ON . The installed BLAS is not fast but, it does not need a Fortran compiler which could be an issue in some operating systems such as Windows. Build If all required dependencies are installed, you can build NASOQ. If you want NASOQ with better performance, reading settings for optional dependencies is helpful. The build instruction below provides a good compromise between easy installation and acceptable performance. Unix (Linux/Mac) cd where/nasoq/cloned cmake -DNASOQ_BLAS_BACKEND = OpenBLAS -DCMAKE_BUILD_TYPE = Release -S . -B build cmake --build build -j 6 Windows cd where/nasoq/cloned cmake -DNASOQ_BLAS_BACKEND = OpenBLAS -DNASOQ_USE_CLAPACK = ON -DCMAKE_BUILD_TYPE = Release -S . -B build cmake --build build --config Release -j 6 A header-only version NASOQ is accessible from here . Github workflows in the NASOQ repository also provides alternative and working build instructions for Mac and Linux . C++ API examples We provide a set of examples to explain NASOQ API. You can use the NASOQ code in-tree or out-of-tree. We explain both possibilities using examples provided in the NASOQ repository. Using NASOQ in-tree: NASOQ examples in nasoq/examples are inside the NASOQ source code and are built with NASOQ. If you want to work in-tree, you can directly modify examples here and rebuild NASOQ. Using NASOQ out-of-tree: You can download the NASOQ code, e.g. as a submodule, and install it while building your project. We provide an example of how to build the NASOQ examples out-of-tree. You can set the NASOQ settings you like before installing NASOQ right from your CMake file. For example, to set the NASOQ BLAS vendor, you can use: set(NASOQ_BLAS_BACKEND \"OpenBLAS\" CACHE STRING \"BLAS implementation for NASOQ to use\") . Here we show a snapshot of the NASOQ QP Solver example ( nasoq/examples/nasoq_main.cpp ): #include <nasoq/nasoq.h> int main (){ /// Allocate ... /// Inputs q [ 0 ] = -4 ; q [ 1 ] = -4 ; // H should be the lower part of a symmetric matrix Hp [ 0 ] = 0 ; Hp [ 1 ] = 1 ; Hp [ 2 ] = 2 ; Hi [ 0 ] = 0 ; Hi [ 1 ] = 1 ; Hx [ 0 ] = 2 ; Hx [ 1 ] = 2 ; // A and C matrices are general matrices Cp [ 0 ] = 0 ; Cp [ 1 ] = 4 ; Cp [ 2 ] = 8 ; Ci [ 0 ] = 0 ; Ci [ 1 ] = 1 ; Ci [ 2 ] = 2 ; Ci [ 3 ] = 3 ; Ci [ 4 ] = 0 ; Ci [ 5 ] = 1 ; Ci [ 6 ] = 2 ; Ci [ 7 ] = 3 ; Cx [ 0 ] = 2 ; Cx [ 1 ] = 1 ; Cx [ 2 ] = -1 ; Cx [ 3 ] = -2 ; Cx [ 4 ] = 1 ; Cx [ 5 ] = -1 ; Cx [ 6 ] = -1 ; Cx [ 7 ] = 1 ; d [ 0 ] = 2 ; d [ 1 ] = 1 ; d [ 2 ] = 1 ; d [ 3 ] = 2 ; /// Solving the QP pronlem nasoq :: Nasoq * qm ; qm = new nasoq :: Nasoq ( sizeH , Hp , Hi , Hx , q , CRows , CCols , Cp , Ci , Cx , d ); qm -> diag_perturb = pow ( 10 , -9 ); qm -> eps_abs = pow ( 10 , -3 ); qm -> max_iter = 0 ; qm -> variant = nasoq :: PREDET ; int converged = qm -> solve (); /// Printing results if ( converged ) std :: cout << \"The problem is converged \\n \" ; // expected x={0.4,1.2}; auto * x = qm -> primal_vars ; std :: cout << \"Primal variables: \" ; for ( int i = 0 ; i < sizeH ; ++ i ) { std :: cout << x [ i ] << \",\" ; } // expected z = {1.6,0,0,0} std :: cout << \" \\n Dual variables: \" ; auto * z = qm -> dual_vars ; for ( int i = 0 ; i < CRows ; ++ i ) { std :: cout << z [ i ] << \",\" ; } /// Free memory ... } For details about inputs, outputs, and settings of NASOQ, please see the NASOQ document page . NOTE: The objective matrix ( H ) should contain all diagonal entries even though the entries are zero. NASOQ Step example An example for NASOQ Step is also provided in the NASOQ example ( nasoq/examples/nasoq_step_main.cpp ). A snapshot of the example is provided below. As shown, NASOQ Step continues iterations till its output is equal to nasoq::NotFinished . #include <nasoq/nasoq_step.h> int main ( int argc , char * argv []){ /// Setting inputs // ... /// Solving the QP pronlem nasoq :: NasoqStep * qm ; qm = new nasoq :: NasoqStep ( sizeH , Hp , Hi , Hx , q , CRows , CCols , Cp , Ci , Cx , d ); qm -> diag_perturb = pow ( 10 , -9 ); qm -> eps_abs = pow ( 10 , -3 ); qm -> max_iter = 0 ; qm -> variant = nasoq :: PREDET ; if ( qm -> solve_init ()){ std :: cout << \"Initialization: \\n \" ; std :: cout << qm -> primal_vars [ 0 ] << \",\" << qm -> primal_vars [ 1 ] << \" \\n \" ; std :: cout << qm -> dual_vars [ 0 ] << \",\" << qm -> dual_vars [ 1 ] << \" \\n \" ; } while ( true ){ auto ret_val = qm -> solve_step (); if ( ret_val != nasoq :: NotFinished ) break ; std :: cout << \"Iteration :\" << qm -> num_iter << \" \\n \" ; std :: cout << qm -> primal_vars [ 0 ] << \",\" << qm -> primal_vars [ 1 ] << \" \\n \" ; std :: cout << qm -> dual_vars [ 0 ] << \",\" << qm -> dual_vars [ 1 ] << \" \\n \" ; } /// Free memory Command-line interface In addition to C++ API, a terminal interface is also provided in the NASOQ repository. To use this interface, you should follow NASOQ instructions to build the interface, i.e., NASOQ-BIN . After the build is done, the terminal interface can be launched by calling NASOQ-BIN with an input QP problem and the list of switches, which can be seen by commanding NASOQ-BIN -h . Some important options are shown below: -i : input SMP file -e : Requested accuracy ,e.g., -3 -v : NASOQ variant, e.g., fixed or tuned For details of options please check NASOQ document page . And for details about SMP format, please check SMP repository page .","title":"Getting Started with NASOQ"},{"location":"getting-started-nasoq/#installation","text":"","title":"Installation"},{"location":"getting-started-nasoq/#getting-the-source","text":"First you should clone the NASOQ repository in your project folder: git clone https://github.com/sympiler/nasoq You can also download one of the NASOQ releases from here .","title":"Getting the source"},{"location":"getting-started-nasoq/#required-dependencies","text":"You should have the following packages to be able to install NASOQ: CMake: version 3.16 or higher C/C++ compiler: Any GCC, ICC, or Clang that support C++11 should work. You can always change your compiler by setting CMAKE_C_COMPILER and CMAKE_CXX_COMPILER . For example, the following changes the compiler to GCC-9: cmake -DCMAKE_C_COMPILER = /usr/bin/gcc-9 -DCMAKE_CXX_COMPILER = /usr/bin/g++-9 ..","title":"Required dependencies"},{"location":"getting-started-nasoq/#optional-dependencies","text":"Following packages improve the performance of NASOQ, but it is not necessary because the NASOQ build system handles it internally. You can skip these details if you are satisfied with the NASOQ performance as installed. We explain different alternatives that the NASOQ build system accepts. OpenMP: OpenMP enables thread-level parallelism in NASOQ. Without OpenMP, NASOQ runs sequentially. We are planning to add TBB as an alternative. If your compiler supports OpenMP, CMake detects it. GCC, ICC, and most LLVM versions natively support OpenMP. METIS: METIS is required for solving linear systems in NASOQ. CMake downloads METIS and installs it if it does not find in your system. You can always add your favorite local METIS installation to CMAKE_PREFIX_PATH=\"\" and NASOQ will use that instead. Alternatively, you can set METIS_INCDIR and METIS_LIBDIR to where METIS header and library are installed, respectively. BLAS Library: NASOQ needs a BLAS library for its supernodal sparse linear solver. It supports both MKL BLAS and OpenBLAS. You should set NASOQ_BLAS_BACKEND when you are installing NASOQ through CMake. The default BLAS is set to MKL as NASOQ is tested more thoroughly with MKL BLAS, but OpenBLAS works as well. MKL BLAS ( -DNASOQ_BLAS_BACKEND=\"MKL\" ): CMake detects the MKL library if you installed it on its default location. If you are using a new version, i.e., called oneAPI, you should set the include and binary directories to CMAKE_PREFIX_PATH (please make sure you set variables, e.g., source /opt/intel/oneapi/setvars.sh ). An example of using oneAPI 2021: cmake -DCMAKE_PREFIX_PATH=\"/opt/intel/oneapi/mkl/2021.2.0/lib/intel64/;/opt/intel/oneapi/mkl/2021.2.0/include/\" .. OpenBLAS ( -DNASOQ_BLAS_BACKEND=\"OpenBLAS\" ): NASOQ's build system downloads OpenBLAS and installs it if it does not detect it in your system. NASOQ should detect OpenBLAS if it is installed through apt or brew . LAPACK Library: The linear solver in NASOQ also uses LAPACK. LAPACK is often part of the BLAS library, such as MKL and OpenBLAS in Mac and Linux. However, if it is not included, or you have any installation issues due to LAPACK, you can use the LAPACK version that NASOQ downloads internally by setting -DNASOQ_USE_CLAPACK=ON . The installed BLAS is not fast but, it does not need a Fortran compiler which could be an issue in some operating systems such as Windows.","title":"Optional dependencies"},{"location":"getting-started-nasoq/#build","text":"If all required dependencies are installed, you can build NASOQ. If you want NASOQ with better performance, reading settings for optional dependencies is helpful. The build instruction below provides a good compromise between easy installation and acceptable performance. Unix (Linux/Mac) cd where/nasoq/cloned cmake -DNASOQ_BLAS_BACKEND = OpenBLAS -DCMAKE_BUILD_TYPE = Release -S . -B build cmake --build build -j 6 Windows cd where/nasoq/cloned cmake -DNASOQ_BLAS_BACKEND = OpenBLAS -DNASOQ_USE_CLAPACK = ON -DCMAKE_BUILD_TYPE = Release -S . -B build cmake --build build --config Release -j 6 A header-only version NASOQ is accessible from here . Github workflows in the NASOQ repository also provides alternative and working build instructions for Mac and Linux .","title":"Build"},{"location":"getting-started-nasoq/#c-api-examples","text":"We provide a set of examples to explain NASOQ API. You can use the NASOQ code in-tree or out-of-tree. We explain both possibilities using examples provided in the NASOQ repository. Using NASOQ in-tree: NASOQ examples in nasoq/examples are inside the NASOQ source code and are built with NASOQ. If you want to work in-tree, you can directly modify examples here and rebuild NASOQ. Using NASOQ out-of-tree: You can download the NASOQ code, e.g. as a submodule, and install it while building your project. We provide an example of how to build the NASOQ examples out-of-tree. You can set the NASOQ settings you like before installing NASOQ right from your CMake file. For example, to set the NASOQ BLAS vendor, you can use: set(NASOQ_BLAS_BACKEND \"OpenBLAS\" CACHE STRING \"BLAS implementation for NASOQ to use\") . Here we show a snapshot of the NASOQ QP Solver example ( nasoq/examples/nasoq_main.cpp ): #include <nasoq/nasoq.h> int main (){ /// Allocate ... /// Inputs q [ 0 ] = -4 ; q [ 1 ] = -4 ; // H should be the lower part of a symmetric matrix Hp [ 0 ] = 0 ; Hp [ 1 ] = 1 ; Hp [ 2 ] = 2 ; Hi [ 0 ] = 0 ; Hi [ 1 ] = 1 ; Hx [ 0 ] = 2 ; Hx [ 1 ] = 2 ; // A and C matrices are general matrices Cp [ 0 ] = 0 ; Cp [ 1 ] = 4 ; Cp [ 2 ] = 8 ; Ci [ 0 ] = 0 ; Ci [ 1 ] = 1 ; Ci [ 2 ] = 2 ; Ci [ 3 ] = 3 ; Ci [ 4 ] = 0 ; Ci [ 5 ] = 1 ; Ci [ 6 ] = 2 ; Ci [ 7 ] = 3 ; Cx [ 0 ] = 2 ; Cx [ 1 ] = 1 ; Cx [ 2 ] = -1 ; Cx [ 3 ] = -2 ; Cx [ 4 ] = 1 ; Cx [ 5 ] = -1 ; Cx [ 6 ] = -1 ; Cx [ 7 ] = 1 ; d [ 0 ] = 2 ; d [ 1 ] = 1 ; d [ 2 ] = 1 ; d [ 3 ] = 2 ; /// Solving the QP pronlem nasoq :: Nasoq * qm ; qm = new nasoq :: Nasoq ( sizeH , Hp , Hi , Hx , q , CRows , CCols , Cp , Ci , Cx , d ); qm -> diag_perturb = pow ( 10 , -9 ); qm -> eps_abs = pow ( 10 , -3 ); qm -> max_iter = 0 ; qm -> variant = nasoq :: PREDET ; int converged = qm -> solve (); /// Printing results if ( converged ) std :: cout << \"The problem is converged \\n \" ; // expected x={0.4,1.2}; auto * x = qm -> primal_vars ; std :: cout << \"Primal variables: \" ; for ( int i = 0 ; i < sizeH ; ++ i ) { std :: cout << x [ i ] << \",\" ; } // expected z = {1.6,0,0,0} std :: cout << \" \\n Dual variables: \" ; auto * z = qm -> dual_vars ; for ( int i = 0 ; i < CRows ; ++ i ) { std :: cout << z [ i ] << \",\" ; } /// Free memory ... } For details about inputs, outputs, and settings of NASOQ, please see the NASOQ document page . NOTE: The objective matrix ( H ) should contain all diagonal entries even though the entries are zero.","title":"C++ API examples"},{"location":"getting-started-nasoq/#nasoq-step-example","text":"An example for NASOQ Step is also provided in the NASOQ example ( nasoq/examples/nasoq_step_main.cpp ). A snapshot of the example is provided below. As shown, NASOQ Step continues iterations till its output is equal to nasoq::NotFinished . #include <nasoq/nasoq_step.h> int main ( int argc , char * argv []){ /// Setting inputs // ... /// Solving the QP pronlem nasoq :: NasoqStep * qm ; qm = new nasoq :: NasoqStep ( sizeH , Hp , Hi , Hx , q , CRows , CCols , Cp , Ci , Cx , d ); qm -> diag_perturb = pow ( 10 , -9 ); qm -> eps_abs = pow ( 10 , -3 ); qm -> max_iter = 0 ; qm -> variant = nasoq :: PREDET ; if ( qm -> solve_init ()){ std :: cout << \"Initialization: \\n \" ; std :: cout << qm -> primal_vars [ 0 ] << \",\" << qm -> primal_vars [ 1 ] << \" \\n \" ; std :: cout << qm -> dual_vars [ 0 ] << \",\" << qm -> dual_vars [ 1 ] << \" \\n \" ; } while ( true ){ auto ret_val = qm -> solve_step (); if ( ret_val != nasoq :: NotFinished ) break ; std :: cout << \"Iteration :\" << qm -> num_iter << \" \\n \" ; std :: cout << qm -> primal_vars [ 0 ] << \",\" << qm -> primal_vars [ 1 ] << \" \\n \" ; std :: cout << qm -> dual_vars [ 0 ] << \",\" << qm -> dual_vars [ 1 ] << \" \\n \" ; } /// Free memory","title":"NASOQ Step example"},{"location":"getting-started-nasoq/#command-line-interface","text":"In addition to C++ API, a terminal interface is also provided in the NASOQ repository. To use this interface, you should follow NASOQ instructions to build the interface, i.e., NASOQ-BIN . After the build is done, the terminal interface can be launched by calling NASOQ-BIN with an input QP problem and the list of switches, which can be seen by commanding NASOQ-BIN -h . Some important options are shown below: -i : input SMP file -e : Requested accuracy ,e.g., -3 -v : NASOQ variant, e.g., fixed or tuned For details of options please check NASOQ document page . And for details about SMP format, please check SMP repository page .","title":"Command-line interface"},{"location":"interfaces/","text":"We are trying to build different interface to ease the use of NASOQ in different frameworks/languages. Eigen interface An Eigen interface is provided in the NASOQ repository in the nasoq/eigen_interface directory. The interface needs Eigen to be installed beforehand. There are two demos, eigen_nasoq_driver.cpp and eigen_lbl_driver.cpp\" that show how NASOQ and LBL can be called from Eigen. You need to only include #include \"lbl_eigen.h\" for using LBL and #include \"nasoq_eigen.h\" for using NASOQ in your Eigen code. Matlab interface The NASOQ Matlab interface needs Libigl and Eigen as well as other dependencies that NASOQ has (see getting started with NASOQ ). A simple manual for installing the Matlab interface is provided in the nasoq/matlab directory.","title":"Interfaces"},{"location":"interfaces/#eigen-interface","text":"An Eigen interface is provided in the NASOQ repository in the nasoq/eigen_interface directory. The interface needs Eigen to be installed beforehand. There are two demos, eigen_nasoq_driver.cpp and eigen_lbl_driver.cpp\" that show how NASOQ and LBL can be called from Eigen. You need to only include #include \"lbl_eigen.h\" for using LBL and #include \"nasoq_eigen.h\" for using NASOQ in your Eigen code.","title":"Eigen interface"},{"location":"interfaces/#matlab-interface","text":"The NASOQ Matlab interface needs Libigl and Eigen as well as other dependencies that NASOQ has (see getting started with NASOQ ). A simple manual for installing the Matlab interface is provided in the nasoq/matlab directory.","title":"Matlab interface"},{"location":"linear-solver/","text":"Algorithm overview LBL is an algorithm for factorizing a sparse indefinite linear system of equations. LBL solves Hx=q Hx=q for x x , where q q is a dense vector, and H H is a sparse symmetric indefinite matrix. To solve the system Hx = q Hx = q , LBL applies LDL factorization to decompose the matrix H H into H = P_{fill} P_{S} (LDL^{T} + E) P_{S}^{T} P_{fill}^{T} H = P_{fill} P_{S} (LDL^{T} + E) P_{S}^{T} P_{fill}^{T} where D D is a blocked diagonal symmetric matrix (due to our use of Bunch-Kaufman pivoting[schenk et.al. 2006]), L L is a sparse lower triangular matrix, E E is a diagonal perturbation matrix (necessary to avoid zero diagonals, which can cause instabilities, P_{fill} P_{fill} is a fill-reducing ordering (such as METIS[karypis 1995]), and P_S P_S is reordering due to pivoting. Given this factorization of the matrix, LBL then uses L L and D D along with q q (the right-hand side) to quickly compute the solution x x via triangular solve and an iterative refinement method. The overall process of the factorization in LBL closely follows that of standard sparse linear system solvers. For efficient factorization, the sparsity pattern of H H is analyzed during symbolic analysis . The symbolic analysis uses the sparsity pattern of H H to construct symbolic information , which consists of the fill-reducing ordering P_{fill} P_{fill} and the sparsity pattern of L L . Symbolic information guides the numeric factorization , which operates on the actual numeric values of H H to compute the nonzero values of L L and D D . Matrices L L and D D are then used to find x x with a lower triangular system solve and blocked diagonal solver. An iterative refinement algorithm, GMRES is also used when accurate solution is required. In addition to solving a standalone linear system of equations, LBL also supports row modification when the sparsity pattern of changes is known ahead of time. The LBL operating mode that supports row modification is used in NASOQ and is called sparsity oriented row modification (SoMoD) . Here we only discuss the interface LBL as a standalone solver. Settings The three parameters that are explained in the NASOQ algorithm is in common with LBL. So the three important parameters are: max_iter: the maximum number of refinement iterations, GMRES for incrementally improving the solution of a linear system after the solve phase; stop_tol: the threshold defining the upper bound for the residual accuracy of the linear system during the refinement phase; diag_perturb: value added to zero-entry diagonals of the matrix to stabilize LBL.","title":"LBL algorithm"},{"location":"linear-solver/#algorithm-overview","text":"LBL is an algorithm for factorizing a sparse indefinite linear system of equations. LBL solves Hx=q Hx=q for x x , where q q is a dense vector, and H H is a sparse symmetric indefinite matrix. To solve the system Hx = q Hx = q , LBL applies LDL factorization to decompose the matrix H H into H = P_{fill} P_{S} (LDL^{T} + E) P_{S}^{T} P_{fill}^{T} H = P_{fill} P_{S} (LDL^{T} + E) P_{S}^{T} P_{fill}^{T} where D D is a blocked diagonal symmetric matrix (due to our use of Bunch-Kaufman pivoting[schenk et.al. 2006]), L L is a sparse lower triangular matrix, E E is a diagonal perturbation matrix (necessary to avoid zero diagonals, which can cause instabilities, P_{fill} P_{fill} is a fill-reducing ordering (such as METIS[karypis 1995]), and P_S P_S is reordering due to pivoting. Given this factorization of the matrix, LBL then uses L L and D D along with q q (the right-hand side) to quickly compute the solution x x via triangular solve and an iterative refinement method. The overall process of the factorization in LBL closely follows that of standard sparse linear system solvers. For efficient factorization, the sparsity pattern of H H is analyzed during symbolic analysis . The symbolic analysis uses the sparsity pattern of H H to construct symbolic information , which consists of the fill-reducing ordering P_{fill} P_{fill} and the sparsity pattern of L L . Symbolic information guides the numeric factorization , which operates on the actual numeric values of H H to compute the nonzero values of L L and D D . Matrices L L and D D are then used to find x x with a lower triangular system solve and blocked diagonal solver. An iterative refinement algorithm, GMRES is also used when accurate solution is required. In addition to solving a standalone linear system of equations, LBL also supports row modification when the sparsity pattern of changes is known ahead of time. The LBL operating mode that supports row modification is used in NASOQ and is called sparsity oriented row modification (SoMoD) . Here we only discuss the interface LBL as a standalone solver.","title":"Algorithm overview"},{"location":"linear-solver/#settings","text":"The three parameters that are explained in the NASOQ algorithm is in common with LBL. So the three important parameters are: max_iter: the maximum number of refinement iterations, GMRES for incrementally improving the solution of a linear system after the solve phase; stop_tol: the threshold defining the upper bound for the residual accuracy of the linear system during the refinement phase; diag_perturb: value added to zero-entry diagonals of the matrix to stabilize LBL.","title":"Settings"},{"location":"repository/","text":"Applications We assemble a repository for sparse QP problems of different scales, most of which come from applications in animation, geometry processing, and simulation. An overview of the repository is provided in the SMP page . Here we explain the storage format that is used in the Sparse Mathematical Programming repository (SMP) and also, the corresponding I/O routines of the format. We also explain how SMP is used in NASOQ benchmark to fairly compare different QP solvers across SMP problems. SMP storage format Sparse Mathematical Programming (SMP) format aims for providing a unified and readable format that is compatible with existing sparse matrix formats such as matrix market format. SMP uses the YAML format to serialize the matrices of a QP problem into a single unified file in a readable format. An example SMP format is shown below: Description\" : | Sparse Mathematical Programming Repository ID = 00000 category = Control application = example name = test01 group = test source = author = Kazem Cheshmi date = 06/20 \"Fixed\" : | 0 \"Inequality\" : | %%MatrixMarket matrix coordinate real symmetric 3 2 4 1 1 10 2 1 1 1 2 -1 3 2 1 \"Inequality l-bounds\" : | %%MatrixMarket matrix array real general 3 1 10 2 -50 \"Inequality u-bounds\" : | %%MatrixMarket matrix array real general 3 1 inf 10 10 \"Linear\" : | %%MatrixMarket matrix array real general 2 1 0 0 \"Quadratic\" : | %%MatrixMarket matrix coordinate real symmetric 2 2 2 1 1 2 2 2 2 As shown a QP problem in the SMP format is stored in the general form of: \\begin{align} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad l \\leq C' x\\leq u \\end{align} that is more compressed than the general form that NASOQ supports which we call general inequality/equality form (IE) and is shown below: \\begin{align} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad C x\\leq d \\end{align} and also more compressed than another general form that we we call general bounded form (bounded) and is illustrated below: \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad l' \\leq C'' x\\leq u' \\end{align} \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad l' \\leq C'' x\\leq u' \\end{align} These three representations lead to the same optimal solution however, they are different in terms of storage requirements and also the number of iterations that one solver might need to solve the problem. SMP conversion We developed a repository for converting different representations of a QP problem, i.e., IE and Bounded forms to SMP and also from SMP to others. The repository does not have any dependency and to install: git clone https://github.com/sympiler/smp-format cd smp-format mkdir build cd build cmake -DCMAKE_BUILD_TYPE = Release .. make After building, three drivers, i.e., ie2smp , bounded2smp , and smp-convertor will be available. The ie2smp driver takes all matrices of a QP problem in IE format which are stored in matrix market format and generates an SMP format. The bounded2smp driver takes all matrices of a QP instance in the bounded format which are again stored in matrix market format and generates an SMP format. The smp-convertor shows an example of how SMP format is used as an intermediate format to convert every two formats together. NASOQ benchmark We also developed a unified framework to run all solvers with their settings for the problems in the SMP repository. The installation of the benchmark depends on the solvers that are added and their dependencies. The instructions for installing the benchmark is provided in the nasoq-benchmarks . Adding a new solver Adding a new solver to the benchmark is easy. The first step is to write a driver for the solver that takes an SMP format and generates the inputs that are needed for the solver. Three examples for OSQP, NASOQ, and Gurobi are provided in drivers subdirectory . As explained, the SMP repository provides support for different QP formats so they can be easily used here. The second step is to update the CMake file in the drivers subdirectory by adding a new project that builds the driver for the new solver. The third step is to add a line to the run_all.sh script, as shown below: echo \"Running [The name of the new solver] ...\" bash scripts/NASOQ_bench.sh $BUILDIR /drivers/ [ New-solver-bin ] $DATASET $eps \"-v [if it has a variant]\" > logs/new-solver-e ${ eps } .csv The run_all script runs all installed solvers for the specified dataset and the requested accuracy and generates the performance profile graphs.","title":"Sparse Mathematical Programming (SMP) Repository"},{"location":"repository/#applications","text":"We assemble a repository for sparse QP problems of different scales, most of which come from applications in animation, geometry processing, and simulation. An overview of the repository is provided in the SMP page . Here we explain the storage format that is used in the Sparse Mathematical Programming repository (SMP) and also, the corresponding I/O routines of the format. We also explain how SMP is used in NASOQ benchmark to fairly compare different QP solvers across SMP problems.","title":"Applications"},{"location":"repository/#smp-storage-format","text":"Sparse Mathematical Programming (SMP) format aims for providing a unified and readable format that is compatible with existing sparse matrix formats such as matrix market format. SMP uses the YAML format to serialize the matrices of a QP problem into a single unified file in a readable format. An example SMP format is shown below: Description\" : | Sparse Mathematical Programming Repository ID = 00000 category = Control application = example name = test01 group = test source = author = Kazem Cheshmi date = 06/20 \"Fixed\" : | 0 \"Inequality\" : | %%MatrixMarket matrix coordinate real symmetric 3 2 4 1 1 10 2 1 1 1 2 -1 3 2 1 \"Inequality l-bounds\" : | %%MatrixMarket matrix array real general 3 1 10 2 -50 \"Inequality u-bounds\" : | %%MatrixMarket matrix array real general 3 1 inf 10 10 \"Linear\" : | %%MatrixMarket matrix array real general 2 1 0 0 \"Quadratic\" : | %%MatrixMarket matrix coordinate real symmetric 2 2 2 1 1 2 2 2 2 As shown a QP problem in the SMP format is stored in the general form of: \\begin{align} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad l \\leq C' x\\leq u \\end{align} that is more compressed than the general form that NASOQ supports which we call general inequality/equality form (IE) and is shown below: \\begin{align} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad C x\\leq d \\end{align} and also more compressed than another general form that we we call general bounded form (bounded) and is illustrated below: \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad l' \\leq C'' x\\leq u' \\end{align} \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad l' \\leq C'' x\\leq u' \\end{align} These three representations lead to the same optimal solution however, they are different in terms of storage requirements and also the number of iterations that one solver might need to solve the problem.","title":"SMP storage format"},{"location":"repository/#smp-conversion","text":"We developed a repository for converting different representations of a QP problem, i.e., IE and Bounded forms to SMP and also from SMP to others. The repository does not have any dependency and to install: git clone https://github.com/sympiler/smp-format cd smp-format mkdir build cd build cmake -DCMAKE_BUILD_TYPE = Release .. make After building, three drivers, i.e., ie2smp , bounded2smp , and smp-convertor will be available. The ie2smp driver takes all matrices of a QP problem in IE format which are stored in matrix market format and generates an SMP format. The bounded2smp driver takes all matrices of a QP instance in the bounded format which are again stored in matrix market format and generates an SMP format. The smp-convertor shows an example of how SMP format is used as an intermediate format to convert every two formats together.","title":"SMP conversion"},{"location":"repository/#nasoq-benchmark","text":"We also developed a unified framework to run all solvers with their settings for the problems in the SMP repository. The installation of the benchmark depends on the solvers that are added and their dependencies. The instructions for installing the benchmark is provided in the nasoq-benchmarks .","title":"NASOQ benchmark"},{"location":"repository/#adding-a-new-solver","text":"Adding a new solver to the benchmark is easy. The first step is to write a driver for the solver that takes an SMP format and generates the inputs that are needed for the solver. Three examples for OSQP, NASOQ, and Gurobi are provided in drivers subdirectory . As explained, the SMP repository provides support for different QP formats so they can be easily used here. The second step is to update the CMake file in the drivers subdirectory by adding a new project that builds the driver for the new solver. The third step is to add a line to the run_all.sh script, as shown below: echo \"Running [The name of the new solver] ...\" bash scripts/NASOQ_bench.sh $BUILDIR /drivers/ [ New-solver-bin ] $DATASET $eps \"-v [if it has a variant]\" > logs/new-solver-e ${ eps } .csv The run_all script runs all installed solvers for the specified dataset and the requested accuracy and generates the performance profile graphs.","title":"Adding a new solver"},{"location":"solver/","text":"Algorithm overview NASOQ focuses on the solution of convex quadratic programming problems to find the linearly constrained minimizers of quadratic energies. In full generality our problem then is \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad C x\\leq d \\end{align} where the unknown minimizer x \\in \\mathbb{R}^n x \\in \\mathbb{R}^n is constrained by linear equality constraints A x=b A x=b and inequality constraints Cx\\leq d Cx\\leq d . Note that in many cases, we may have only inequality or equality constraints. However, in the following, without loss of generality, we consider the full mixed case. Here the symmetric matrix H H is, either by construction or standard user regularization, a positive-definite matrix, thus the QP is strictly convex. NASOQ is an active-set QP solver based on Goldfarb-Idnani (GI) [Goldfarb and Idnani, 1983] strategy. Active-set methods start with a feasible solution and keep a running set of proposed active inequality constraints \\mathcal{W} \\mathcal{W} to reach the optimal solution while maintaining feasibility conditions. Active-set methods are then either primal-feasible, preserving the primal-feasibility condition or else are dual-feasible, preserving the non-negativity condition. GI is a dual-feasible active-set approach, and so enables direct and inexpensive initialization. NASOQ begins by initializing an empty active-set proposal, \\mathcal{W} = \\emptyset \\mathcal{W} = \\emptyset with zero dual variables, z_0 = 0 z_0 = 0 . The resulting initial KKT system to solve is then the indefinite linear system, \\begin{bmatrix} H & A^T\\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} x_0\\\\ y_0 \\end{bmatrix} = \\begin{bmatrix} -q\\\\ b \\end{bmatrix} \\begin{bmatrix} H & A^T\\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} x_0\\\\ y_0 \\end{bmatrix} = \\begin{bmatrix} -q\\\\ b \\end{bmatrix} Then, each successive iteration of NASOQ improves the last iterate's solution by updating the active-set proposal \\mathcal{W} \\mathcal{W} and so the corresponding active-set constraint matrix C_{\\mathcal{W}} C_{\\mathcal{W}} and the right-hand side constraint vector c_{w} c_{w} . The NASOQ algorithm updates the active set by only adding one or removing one constraint in each successive iteration. Here w w is the activated constraint. The next descent direction for the QP is then determined by solving the updated KKT system, \\begin{bmatrix} H & A^T & C_{\\mathcal{W}}^T\\\\ A & 0 & 0 \\\\C_{\\mathcal{W}} & 0 & 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta z \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{w} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} \\begin{bmatrix} H & A^T & C_{\\mathcal{W}}^T\\\\ A & 0 & 0 \\\\C_{\\mathcal{W}} & 0 & 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta z \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{w} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} The dual and primal variables of the next iteration are then updated by finding step lengths along the computed descent directions, i.e., \\Delta x, \\Delta y, \\Delta z \\Delta x, \\Delta y, \\Delta z . The step lengths ensure that the activated constraint becomes primal-feasible and all dual variables remain dual-feasible. Thus, in each iteration, both the dual and primal variables corresponding to the constraints in the active set are both non-negative and primal-feasible. Variants NASOQ has two variants: NASOQ-Fixed and NASOQ-Tuned , and each of these two variants individually offers a different balance in the trade-off between efficiency and accuracy for larger-scale problems. A key feature of NASOQ is that in our construction of the linear system solver, i.e., LBL and the row modification, i.e., SoMoD we expose three parameters with direct and intuitive interpretations that enable us to balance efficiency against accuracy for different applications and problem scales. These three parameters are: max_iter: the maximum number of refinement iterations for incrementally improving the solution of a KKT system after the solve phase; stop_tol: the threshold defining the upper bound for the residual accuracy of the KKT system during the refinement phase; diag_perturb: value added to zero-entry diagonals of the KKT matrix to stabilize LBL and row modification in SoMod. NASOQ-Fixed works well across the board without changing a default setting. To use NASOQ-Fixed, you can set nasoq->variant = Fixed . NASOQ-Fixed settings are slightly different from the settings in the siggraph2020 paper. The max_iter parameter in the new settings is decremented by one so it runs faster. NASOQ-Tuned uses a range of reasonable settings for these three parameters known as a priori, to perform a rapid sweep for improved accuracy. The setting for activating NASOQ-Tuned is: nasoq->variant = Tuned (This mode has not been included in the API yet). NASOQ Step NASOQ iteratively improves the solution of a QP problem. It happens in some applications that the solution after a number of iterations is enough and waiting for the final solution is not necessary. Or using an intermediate solution might help simulations progress. NASOQ Step is an interface to the NASOQ solver that provides the solution after each iteration. Users can use the intermediate solutions based on their application's needs. Termination criteria The termination criteria in NASOQ are four conditions that are listed below: Primal-feasibility: \\Big( (Ax-b)^T, (\\max(\\textbf{0},Cx-d))^T \\Big)^T \\| < \\epsilon_f \\Big( (Ax-b)^T, (\\max(\\textbf{0},Cx-d))^T \\Big)^T \\| < \\epsilon_f Stationarity: |Hx + q + A^{T}y + C^{T}z\\| < \\epsilon_s |Hx + q + A^{T}y + C^{T}z\\| < \\epsilon_s Complementarity: |z \\odot (Cx-d)\\| < \\epsilon_c |z \\odot (Cx-d)\\| < \\epsilon_c , Here \\odot \\odot is the Hadamard (element-wise) product. Non-negativity: |\\min(\\textbf{0},z)\\| < \\epsilon_n |\\min(\\textbf{0},z)\\| < \\epsilon_n We design NASOQ and analyze QP methods on their ability to drive all four of these measures ( \\infty \\infty -norm) below a common, maximum error threshold accuracy: \\epsilon \\geq \\max(\\epsilon_f,\\epsilon_s,\\epsilon_c,\\epsilon_n) \\epsilon \\geq \\max(\\epsilon_f,\\epsilon_s,\\epsilon_c,\\epsilon_n) . While necessary accuracies for each of the four measures certainly change per application, a desirable goal for a general-purpose QP algorithm is to solve every reasonable problem to any requested accuracy. Here we design for general-purpose QP problems and so do not predict a priori what measures are most important. Thus we evaluate fitness by asking each solve to drive all measures below \\epsilon \\epsilon . To set the accuracy threshold in NASOQ, you may use the following: nasoq->eps_abs = 1e-3; Settings The three different parameters, max_iter, stop_tol, diag_perturb that exist in NASOQ, often show a significant effect on the performance and accuracy of the solver. Also, requesting a more accurate solution, i.e., lower termination criteria or eps_abs often leads to much more number of iterations and thus slower convergence time. NASOQ has some pre-defined variants, i.e., fixed and tuned. NASOQ-Tuned is designed conservatively for the lowest failure rate. NASOQ-Fixed often provides a reasonable balance between balance and failure-rate. However, a customized setting can lead to better performance if the requirements of the application are known. Here we provide a few suggestions based on our experience with working with different real applications: Setting Property NASOQ Variant max_iter stop_tol diag_perturb eps_abs Example Applications Low accuracy and fast PREDET 0 1e-15 1e-9 1e-3 Geometry processing, Model reconstruction accurate enough PREDET 1 1e-15 1e-9 1e-6 Contact simulations, Control The PREDET variant of NASOQ is a variant that takes the input settings determined by the user. If you are not sure, you may start with the fixed variant of NASOQ. You can also set the maximum number of NASOQ solver iterations by setting max_iter_nas . After NASOQ's iterations reach this number, it terminates and returns the last solution. Return value NASOQ solver return value has four states: 0: Infeasible the problem is unbounded. 1: Optimal When primal-feasibility, stationary, and non-negativity are satisfied. 2: Inaccurate only primal-feasibility is satisfied. 3: NotConverged None of the termination criteria are satisfied.","title":"NASOQ algorithm"},{"location":"solver/#algorithm-overview","text":"NASOQ focuses on the solution of convex quadratic programming problems to find the linearly constrained minimizers of quadratic energies. In full generality our problem then is \\begin{align} \\label{eq:qp} \\min_x \\quad \\frac{1}{2} x^THx + q^Tx \\quad \\text{s.t.} \\quad Ax=b, \\quad C x\\leq d \\end{align} where the unknown minimizer x \\in \\mathbb{R}^n x \\in \\mathbb{R}^n is constrained by linear equality constraints A x=b A x=b and inequality constraints Cx\\leq d Cx\\leq d . Note that in many cases, we may have only inequality or equality constraints. However, in the following, without loss of generality, we consider the full mixed case. Here the symmetric matrix H H is, either by construction or standard user regularization, a positive-definite matrix, thus the QP is strictly convex. NASOQ is an active-set QP solver based on Goldfarb-Idnani (GI) [Goldfarb and Idnani, 1983] strategy. Active-set methods start with a feasible solution and keep a running set of proposed active inequality constraints \\mathcal{W} \\mathcal{W} to reach the optimal solution while maintaining feasibility conditions. Active-set methods are then either primal-feasible, preserving the primal-feasibility condition or else are dual-feasible, preserving the non-negativity condition. GI is a dual-feasible active-set approach, and so enables direct and inexpensive initialization. NASOQ begins by initializing an empty active-set proposal, \\mathcal{W} = \\emptyset \\mathcal{W} = \\emptyset with zero dual variables, z_0 = 0 z_0 = 0 . The resulting initial KKT system to solve is then the indefinite linear system, \\begin{bmatrix} H & A^T\\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} x_0\\\\ y_0 \\end{bmatrix} = \\begin{bmatrix} -q\\\\ b \\end{bmatrix} \\begin{bmatrix} H & A^T\\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} x_0\\\\ y_0 \\end{bmatrix} = \\begin{bmatrix} -q\\\\ b \\end{bmatrix} Then, each successive iteration of NASOQ improves the last iterate's solution by updating the active-set proposal \\mathcal{W} \\mathcal{W} and so the corresponding active-set constraint matrix C_{\\mathcal{W}} C_{\\mathcal{W}} and the right-hand side constraint vector c_{w} c_{w} . The NASOQ algorithm updates the active set by only adding one or removing one constraint in each successive iteration. Here w w is the activated constraint. The next descent direction for the QP is then determined by solving the updated KKT system, \\begin{bmatrix} H & A^T & C_{\\mathcal{W}}^T\\\\ A & 0 & 0 \\\\C_{\\mathcal{W}} & 0 & 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta z \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{w} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} \\begin{bmatrix} H & A^T & C_{\\mathcal{W}}^T\\\\ A & 0 & 0 \\\\C_{\\mathcal{W}} & 0 & 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta z \\\\ \\end{bmatrix} = \\begin{bmatrix} c_{w} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} The dual and primal variables of the next iteration are then updated by finding step lengths along the computed descent directions, i.e., \\Delta x, \\Delta y, \\Delta z \\Delta x, \\Delta y, \\Delta z . The step lengths ensure that the activated constraint becomes primal-feasible and all dual variables remain dual-feasible. Thus, in each iteration, both the dual and primal variables corresponding to the constraints in the active set are both non-negative and primal-feasible.","title":"Algorithm overview"},{"location":"solver/#variants","text":"NASOQ has two variants: NASOQ-Fixed and NASOQ-Tuned , and each of these two variants individually offers a different balance in the trade-off between efficiency and accuracy for larger-scale problems. A key feature of NASOQ is that in our construction of the linear system solver, i.e., LBL and the row modification, i.e., SoMoD we expose three parameters with direct and intuitive interpretations that enable us to balance efficiency against accuracy for different applications and problem scales. These three parameters are: max_iter: the maximum number of refinement iterations for incrementally improving the solution of a KKT system after the solve phase; stop_tol: the threshold defining the upper bound for the residual accuracy of the KKT system during the refinement phase; diag_perturb: value added to zero-entry diagonals of the KKT matrix to stabilize LBL and row modification in SoMod. NASOQ-Fixed works well across the board without changing a default setting. To use NASOQ-Fixed, you can set nasoq->variant = Fixed . NASOQ-Fixed settings are slightly different from the settings in the siggraph2020 paper. The max_iter parameter in the new settings is decremented by one so it runs faster. NASOQ-Tuned uses a range of reasonable settings for these three parameters known as a priori, to perform a rapid sweep for improved accuracy. The setting for activating NASOQ-Tuned is: nasoq->variant = Tuned (This mode has not been included in the API yet).","title":"Variants"},{"location":"solver/#nasoq-step","text":"NASOQ iteratively improves the solution of a QP problem. It happens in some applications that the solution after a number of iterations is enough and waiting for the final solution is not necessary. Or using an intermediate solution might help simulations progress. NASOQ Step is an interface to the NASOQ solver that provides the solution after each iteration. Users can use the intermediate solutions based on their application's needs.","title":"NASOQ Step"},{"location":"solver/#termination-criteria","text":"The termination criteria in NASOQ are four conditions that are listed below: Primal-feasibility: \\Big( (Ax-b)^T, (\\max(\\textbf{0},Cx-d))^T \\Big)^T \\| < \\epsilon_f \\Big( (Ax-b)^T, (\\max(\\textbf{0},Cx-d))^T \\Big)^T \\| < \\epsilon_f Stationarity: |Hx + q + A^{T}y + C^{T}z\\| < \\epsilon_s |Hx + q + A^{T}y + C^{T}z\\| < \\epsilon_s Complementarity: |z \\odot (Cx-d)\\| < \\epsilon_c |z \\odot (Cx-d)\\| < \\epsilon_c , Here \\odot \\odot is the Hadamard (element-wise) product. Non-negativity: |\\min(\\textbf{0},z)\\| < \\epsilon_n |\\min(\\textbf{0},z)\\| < \\epsilon_n We design NASOQ and analyze QP methods on their ability to drive all four of these measures ( \\infty \\infty -norm) below a common, maximum error threshold accuracy: \\epsilon \\geq \\max(\\epsilon_f,\\epsilon_s,\\epsilon_c,\\epsilon_n) \\epsilon \\geq \\max(\\epsilon_f,\\epsilon_s,\\epsilon_c,\\epsilon_n) . While necessary accuracies for each of the four measures certainly change per application, a desirable goal for a general-purpose QP algorithm is to solve every reasonable problem to any requested accuracy. Here we design for general-purpose QP problems and so do not predict a priori what measures are most important. Thus we evaluate fitness by asking each solve to drive all measures below \\epsilon \\epsilon . To set the accuracy threshold in NASOQ, you may use the following: nasoq->eps_abs = 1e-3;","title":"Termination criteria"},{"location":"solver/#settings","text":"The three different parameters, max_iter, stop_tol, diag_perturb that exist in NASOQ, often show a significant effect on the performance and accuracy of the solver. Also, requesting a more accurate solution, i.e., lower termination criteria or eps_abs often leads to much more number of iterations and thus slower convergence time. NASOQ has some pre-defined variants, i.e., fixed and tuned. NASOQ-Tuned is designed conservatively for the lowest failure rate. NASOQ-Fixed often provides a reasonable balance between balance and failure-rate. However, a customized setting can lead to better performance if the requirements of the application are known. Here we provide a few suggestions based on our experience with working with different real applications: Setting Property NASOQ Variant max_iter stop_tol diag_perturb eps_abs Example Applications Low accuracy and fast PREDET 0 1e-15 1e-9 1e-3 Geometry processing, Model reconstruction accurate enough PREDET 1 1e-15 1e-9 1e-6 Contact simulations, Control The PREDET variant of NASOQ is a variant that takes the input settings determined by the user. If you are not sure, you may start with the fixed variant of NASOQ. You can also set the maximum number of NASOQ solver iterations by setting max_iter_nas . After NASOQ's iterations reach this number, it terminates and returns the last solution.","title":"Settings"},{"location":"solver/#return-value","text":"NASOQ solver return value has four states: 0: Infeasible the problem is unbounded. 1: Optimal When primal-feasibility, stationary, and non-negativity are satisfied. 2: Inaccurate only primal-feasibility is satisfied. 3: NotConverged None of the termination criteria are satisfied.","title":"Return value"}]}